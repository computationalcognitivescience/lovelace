<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Subset choice</title>
  <meta name="description" content="In this chapter you will learn how to use computer simulations as a theoreticaltool, namely to analyze the consequences different formalizations of verbalthe...">

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  
  

  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

 <!--   <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
  


  <link rel="stylesheet" type="text/css" href="/lovelace/css/tufte.css">
  <!-- <link rel="stylesheet" type="text/css" href="/lovelace/css/print.css" media="print"> -->

  <link rel="canonical" href="/lovelace/part_iii/sim_subset_choice">

  <link rel="alternate" type="application/rss+xml" title="THEORETICAL MODELING" href="/lovelace/feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
	<div class="nav-wrapper">
	<div class="nav-left">
	<a href="/lovelace/"><img class="badge" src="/lovelace/assets/img/cover.png" alt="CH"></a>
	</div>
	<div class="nav-right">
	
		
  	
		
  	
		
		    
		      <a href="/lovelace/home">Home</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part1">I - Intro</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part2">II - Formalizing</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part3">III - Simulating</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part4">IV - Advanced Topics</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/css/print.css"></a>
		    
	    
  	
		
  	
		
  	
	</div>
	</div>
	</nav>
</header>

    <article class="group">
      
<h1>Chapter 10 - Subset choice</h1>


<p>In this chapter you will learn how to use computer simulations as a theoretical
tool, namely to analyze the consequences different formalizations of verbal
theories. To reach that goal, you will also learn how to read an implementation
of formal theory in Scala <code class="language-plaintext highlighter-rouge">mathlib</code>. At the end of this chapter, you will be
able to use (adapt and run) the provided simulation code to compare three formal
models. You will be able to test your intuitions about the theory and derive qualitative differences between them.</p>

<p>We pick up the conversation between Verbal and Formal from <a href="/lovelace/part_ii/subset#dialogue-1-formalizing-inviting-guests">Chapter 4 - Subset Choice</a>. Formal is very excited to share the computer simulations they implemented of the theoretical models Formal and Verbal created. Formal has some suggestions on how to use the simulations, which they explain to Verbal.</p>

<div class="indent-4 ">
  <p><strong>Formal:</strong> Welcome dr. Verbal! As promised, I have implemented computer simulations for three of our computational-level models.</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> That’s great. You said we can use the simulations to explore the models’ empirical implications. How does that work?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> The three formal models each make different tradeofs in optimizing selecting guests…</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> Yes, I remember. Shall I run some experiments to see which one is best?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> …wait! Before you leave me alone again for a few months, let’s do a bit more theory before the test (van Rooij &amp; Baggio, 2021). Do we even know if the models are different in important and meaningful ways? Even if they are different, are they so under sensible conditions?</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> But the formalizations are different, so the models must behave differently, right?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong>
Not necessarily. Formalizations that are different may behave the same or very similarly. Sometimes we can analytically derive such equivalence<label for="sn-id-equivalence" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-equivalence" class="margin-toggle" /><span class="sidenote">You can read about mathematically proving model equivalence in <a href="/lovelace/part_ii/coherence#Equivalence">Chapter 5 - Coherence</a>. </span> but this is not always possible. Then computer simulations can come in handy.</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> Ah, I see. I would like to know if there are important differences between the theories. That way we can possibly rule out theories that cannot explain the phenomenon or find ways to update them, just like when we were formalizing my verbal theories.</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> Indeed, that is the idea.</p>
</div>

<p>If you jumped here directly from <a href="/lovelace/part_ii/subset">Chapter 4 - Subset choice</a>
you may find it helpful to first read <a href="/lovelace/part_ii/mathlib">Chapter 9 - Scala and mathlib</a> to learn how to read (and write) Scala code using the <code class="language-plaintext highlighter-rouge">mathlib</code> library. In addition to the default <code class="language-plaintext highlighter-rouge">mathlib</code> library, the simulation code on this page includes supporting code which we explain first.</p>

<h2 id="supporting-code">Supporting code</h2>
<p>Running simulations requires input instances as specified by the theoretical model. While we could code input by hand, that is a lot of work. The beauty of using computer simulations is that it can do the hard work for us by <em>automatically</em> generating input. To that end, Formal has written supporting code. <label for="sn-id-helper" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-helper" class="margin-toggle" /><span class="sidenote">Supporting code is often written specifically for a domain. For example, <a href="/lovelace/part_iii/sim_coherence">simulating Coherence</a> uses different support code. </span></p>

<p>For now, it is not important that you know how to write support code. However, in order to explore and adapt the code that Formal has provided, being able to <em>use</em> support code is recommended. Let’s explore some examples. Remember that you can run (and adapt) the code in your browser using the <button style="background: rgba(255,255,255,0.6) !important;color: rgba(0, 0, 0, 0.6) !important;border-radius: 5px;border: 1px solid #ddd;font-family: Lato,'Helvetica Neue',Arial,Helvetica,sans-serif;font-size: 14px; padding: 3px 8px;transition: all 350ms ease;"><img src="https://embed.scalafiddle.io/runicon.png" style="padding: 0;margin: 0 0 4px 0;vertical-align: middle;width: 16px;height: 16px;display: inline;" />Run</button> button.</p>

<p>The theoretical models for selecting invitees (subset choice) take as input sets of persons and a function that for pairs of persons returns if they like eachother or not. The support code helps us generate these parts of the input.</p>

<h3 id="persons">Persons</h3>
<p>A particular person is identified by their name, and can be defined by using <code class="language-plaintext highlighter-rouge">Person(name: String)</code>. This function takes a string as input and returns a Person object with the given name:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Person</span><span class="o">(</span><span class="s">"Jamie"</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>Persons with the same name are considered to refer to the same individual, since the computer cannot distinguish between them.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">person1</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Jamie"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">person2</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Jamie"</span><span class="o">)</span>

<span class="n">person1</span> <span class="o">==</span> <span class="n">person2</span>
</code></pre></div></div>
</div>

<p>We can also create random persons. Their names are randomly selected from a predefined list with 100 names. Running the code below multiple times will create different persons.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Person</span><span class="o">.</span><span class="py">random</span>
</code></pre></div></div>
</div>

<p>We can also generate groups of <code class="language-plaintext highlighter-rouge">n</code> random individuals.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>These functions will help us create sets of persons. We can then use <code class="language-plaintext highlighter-rouge">mathlib</code> to work with these sets as expected. For example, we can create a set of random persons \(P\), randomly take 2 persons who are liked \(L\), and create a set of persons who are disliked \(D=P \setminus L\):</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>            <span class="c1">// Take 2 people from persons.</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="n">persons</span> <span class="o">\</span> <span class="n">personsLiked</span>

<span class="nf">println</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">personsDisliked</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">persons</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h3 id="like-function">Like-function</h3>
<p>The final support code Formal provided is used to create like relationships between persons. In the formal model this function is defined as \(like: P\times P \rightarrow \{true,false\}\). After discussing with a colleague (see <a href="/lovelace/part_ii/subset#try-again">Exercise X in Chapter 4</a>), Formal recognized that the like function was intended to exclude reflection (i.e., self-liking) and is symmetrical \(like(a,b)=like(b,a)\) (i.e., it formalizes like or dislike <em>eachother</em>).<label for="sn-id-helper" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-helper" class="margin-toggle" /><span class="sidenote">The formalizations in this chapter are updated with these properties. </span></p>

<p>One could specify a like relationship manually. Simply create persons, store them in values so we can refer to them and then use <code class="language-plaintext highlighter-rouge">likes</code> or <code class="language-plaintext highlighter-rouge">dislikes</code> to create like relationships.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">lela</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lela"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">carlos</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Carlos"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ervin</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Ervin"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="n">lela</span> <span class="n">likes</span> <span class="n">carlos</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">carlos</span> <span class="n">dislikes</span> <span class="n">ervin</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">carlos</span> <span class="n">dislikes</span> <span class="n">lela</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>Specifying a <em>complete</em> like function for a set of persons, however, will be quite a chore: for each pair you need to explicate if \(a\) likes \(b\) and vice versa. For \(10\) persons, that is a list of \(10 \cdot 10=100\) likes. Support functions help us reduce this chore.</p>

<p><label for="mn-id-runbutton" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-id-runbutton" class="margin-toggle" /><span class="marginnote">The code snippet below is interleaved with explanation text. Pressing <button style="background: rgba(255,255,255,0.6) !important;color: rgba(0, 0, 0, 0.6) !important;border-radius: 5px;border: 1px solid #ddd;font-family: Lato,,Arial,Helvetica,sans-serif;font-size: 14px; padding: 3px 8px;transition: all 350ms ease;"><img src="https://embed.scalafiddle.io/runicon.png" style="padding: 0;margin: 0 0 4px 0;vertical-align: middle;width: 16px;height: 16px;display: inline;" />Run</button> removes the explanation text to run the code. You can get the explanation back by reloading this webpage. </span> When given a partial specification of the like function, we can complete it by assuming that any non-specified relationship is a dislike. Use the support function <code class="language-plaintext highlighter-rouge">.deriveLikeFunction(partialLikes: Set[Likes])</code> on a set of persons to create a like function for which the domain consists of all pairs of persons (including \((a,b)\), \((b,a)\) and \(a,a\)). It will complete <code class="language-plaintext highlighter-rouge">partialLikes</code> by assuming non-specified relationships are dislikes.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-layout="v50">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">lela</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lela"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">carlos</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Carlos"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ervin</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Ervin"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">carlos</span><span class="o">,</span> <span class="n">ervin</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">partialLikings</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">lela</span> <span class="n">likes</span> <span class="n">carlos</span><span class="o">,</span> <span class="n">carlos</span> <span class="n">likes</span> <span class="n">ervin</span><span class="o">,</span><span class="n">carlos</span> <span class="n">dislikes</span> <span class="n">lela</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">deriveLikeFunction</span><span class="o">(</span><span class="n">partialLikings</span><span class="o">)</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">Viz.render()</code> function can draw graphs specified in the <a href="https://graphviz.org/doc/info/lang.html">DOT language</a>. The <code class="language-plaintext highlighter-rouge">.toDotString(like)</code> helper function transforms persons and a like function to graph figures.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">persons</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">like</span><span class="o">))</span>
</code></pre></div></div>
<p>And we can view the truth values associated with all pairs of persons.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">(</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">carlos</span><span class="o">),</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">ervin</span><span class="o">),</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">carlos</span><span class="o">,</span> <span class="n">ervin</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>
</div>

<p>While this approach is useful to manually explore small examples, it still is a lot of manual work. Wouldn’t it be nice if we can generate a complete like function randomly? Use the support function <code class="language-plaintext highlighter-rouge">.randomLikeFunction(probability: Double)</code> on a set of persons to create a random like function. For each pair (including \((a,b)\), \((b,a)\) and \(a,a\)), it generates <code class="language-plaintext highlighter-rouge">true</code> with probability equal to the ratio or false otherwise.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="700" data-layout="v50">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">lela</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lela"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">carlos</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Carlos"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ervin</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Ervin"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">carlos</span><span class="o">,</span> <span class="n">ervin</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(</span><span class="mf">0.7</span><span class="o">)</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">persons</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">like</span><span class="o">))</span>

<span class="nc">List</span><span class="o">(</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">carlos</span><span class="o">),</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">ervin</span><span class="o">),</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">carlos</span><span class="o">,</span> <span class="n">ervin</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>
</div>

<div class="question-top"><div class="question" id="question-1"><div class="question-body"><div class="question-header">Question 10.1</div> <p>What happens to the output of the like function when you change the probability?</p>
<div class="answer" id="question-1-heading-1"><a onclick="document.getElementById('question-1-answer-1').style.display = document.getElementById('question-1-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-1-answer-1" style="display: none;"><p>Try changing the probability value (the input of the function <code class="language-plaintext highlighter-rouge">randomLikeFunction</code>) and see what changes in the output.</p>
</div></div>
</div></div></div>

<p>A final example to illustrate how to generate a random input instance. An alternative visualization is used to indicate which persons are liked by the host or not. Note that generating a visualization graph with many persons will not display properly or potentially crash your browser due to the many relationships.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="700" data-layout="v20">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="n">persons</span> <span class="o">\</span> <span class="n">personsLiked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(</span><span class="mf">0.7</span><span class="o">)</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">persons</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>
</code></pre></div></div>
</div>

<div class="question-top"><div class="question" id="question-2"><div class="question-body"><div class="question-header">Question 10.2</div> <p>With these support functions, we can randomly create instances for the formal models of selecting invitees. Why is this helpful?</p>
<div class="answer" id="question-.2-heading-1"><a onclick="document.getElementById('question-.2-answer-1').style.display = document.getElementById('question-.2-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.2-answer-1" style="display: none;"><p>It save a lot of manual work.</p>

<div class="question" id="question-2.0"><div class="question-body"><div class="question-header">Question 10.2.0</div> <p>Can you think of another use?</p>
<div class="answer" id="question-2.0-heading-1"><a onclick="document.getElementById('question-2.0-answer-1').style.display = document.getElementById('question-2.0-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-2.0-answer-1" style="display: none;"><p>You can compare model behaviour for the same input.</p>

<div class="question" id="question-2.0.0"><div class="question-body"><div class="question-header">Question 10.2.0.0</div> <p>Can you think of another use?</p>
<div class="answer" id="question-2.0.0-heading-1"><a onclick="document.getElementById('question-2.0.0-answer-1').style.display = document.getElementById('question-2.0.0-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-2.0.0-answer-1" style="display: none;"><p>You can generate different inputs at random and see if (and how) model behaviour changes as a function of the input.</p>

<div class="question" id="question-2.0.0.0"><div class="question-body"><div class="question-header">Question 10.2.0.0.0</div> <p>Can you think of another use?</p>
</div></div>
</div></div>
</div></div>
</div></div>
</div></div>
</div></div>
</div></div></div>

<h2 id="simulating-selecting-invitees">Simulating <span style="font-variant: small-caps; font-style: normal;">Selecting Invitees</span></h2>

<p>In this section we cover how to simulate <span style="font-variant: small-caps;">Selecting invitees (version
4, 5 and 6) </span>. You will learn how to read Scala <code class="language-plaintext highlighter-rouge">mathlib</code> simulation code
and how it relates to the formalization. We go through <span style="font-variant: small-caps;">Selecting
invitees (version 4) </span> step by step, after which you can explore versions 5 and
6 yourself. To make the code more readable, we use names in the code that are
more descriptive than the single letters used in math (see Table 1).</p>

<p><label for="Table-ID1" class="margin-toggle"> ⊕</label><input type="checkbox" id="Table-ID1" class="margin-toggle" /><span class="marginnote">Table 1: the mapping from math notation to Scala code. </span></p>
<div class="table-wrapper" style="margin-top:3rem;">

  <table>
    <thead>
      <tr>
        <th style="text-align: left">Math</th>
        <th style="text-align: left">Scala</th>
        <th style="text-align: left">Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: left">\(P\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">persons</code></td>
        <td style="text-align: left">Set of persons from which to select invitees.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(L\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">personsLiked</code></td>
        <td style="text-align: left">Subset of persons that is liked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(D\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">personsDisliked</code></td>
        <td style="text-align: left">Subset of persons that is disliked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(like\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">like</code></td>
        <td style="text-align: left">Function that captures if two persons like each other or not.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(k\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">k</code></td>
        <td style="text-align: left">Value that states how many of the invited persons at most can be disliked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(G\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">invitees</code></td>
        <td style="text-align: left">Set of invited persons.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(X\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">x</code></td>
        <td style="text-align: left">Set of all unique pairs of persons that like each other.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(Y\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">y</code></td>
        <td style="text-align: left">Set of all unique pairs of persons that dislike each other.</td>
      </tr>
    </tbody>
  </table>

</div>

<div class="stopandthink"><div class="st-header">Stop and think</div>
<p>Take a moment to familiarize yourself again with the
formalization. If you need more context, you can go back to <a href="/lovelace/part_ii/subset#">Chapter 4 - Subset
choice</a> where the formalization was introduced.</p>
</div>

<p><span class="problemtitle">Selecting invitees (version 4)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), a function \(like: P \times P \rightarrow \{true, false\}\), and a threshold value \(k\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|G\cap D| \leq k\) and \(|X| + |G|\) is maximized (where \(X = \{p_i,p_j \in G~|~like(p_i,p_j) = true \wedge i\neq j\}\)).</p>

<p>Let’s see how this formalization translates to simulation code. The
formalization is implemented in the <code class="language-plaintext highlighter-rouge">si4</code> function, all of the input (\(P\),
\(L\), \(D\), \(like\) and \(k\)) is listed as an argument of the function. The
type of the output also needs to be defined. In this case the output is a subset
\(G\subseteq P\) of persons, translating to type <code class="language-plaintext highlighter-rouge">Set[Person]</code>.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">si4</span><span class="o">(</span><span class="n">persons</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsLiked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsDisliked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span>
        <span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</code></pre></div></div>

<p>The input in the formalization is subject to a few constraints. We check those
constraints in the code and stop the program of the constraints are not met with
an informative error message.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Input must satisfy these constraints, otherwise error.</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsLiked must be a subset of persons"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsDisliked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsDisliked must be a subset of persons"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">/\</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span>
          <span class="s">"personsLiked intersect personsDisliked must be emtpy"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">\/</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsLiked union personsLiked must equal persons"</span><span class="o">)</span>
</code></pre></div></div>

<p>The output is defined using two properties. To define output using the set
builder we write two functions that compute these properties. First, the host
wants to invite at most \(k\) people they dislike <span>\(|G \cap D|\leq
k\)</span>. This function returns a Boolean if a given (sub)set of people does
not have this property.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Specify that invitees is valid if |G /\ D| &lt;= k.</span>
  <span class="k">def</span> <span class="nf">atMostKDislikes</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">invitees</span> <span class="o">/\</span> <span class="n">personsDisliked</span><span class="o">).</span><span class="py">size</span> <span class="o">&lt;=</span> <span class="n">k</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Second, the formalization
states that the number of invited pairs that like each other plus the number of
invited people \(|X| + |G|\) is maximal. This is an optimality condition. This
function computes for a given (sub)set of people, the set \(X\) and returns an
integer corresponding to \(|X| + |G|\).</p>

<p><label for="mn-id-tupled" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-id-tupled" class="margin-toggle" /><span class="marginnote">The <code class="language-plaintext highlighter-rouge">.tupled</code> function transforms a function
with \(n\) arguments into a function with 1 argument, where that argument is an
\(n\)-tuple. This is needed when applying a function on a set of tuples that
correspond to the arguments of that function. </span></p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Specify the optimality condition.</span>
  <span class="k">def</span> <span class="nf">xg</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// The number of unique pairs that like eachother.</span>
    <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="o">{</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">uniquePairs</span> <span class="o">|</span> <span class="nv">like</span><span class="o">.</span><span class="py">tupled</span> <span class="o">}.</span><span class="py">size</span>
    <span class="c1">// The number of total invitees.</span>
    <span class="k">val</span> <span class="nv">g</span> <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">size</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">g</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Here we specify the set of possible valid outputs. Remember that for any given
formalization multiple possible outputs may exist that satisfy the output
conditions. Below, we consider all possible subsets of people (the powerset
\(\mathcal{P}(P)\)). Any \(G\in\mathcal{P}(P)\) is a subset of people
\(G\subseteq P\). From this set of sets we build a set of sets of people that
satisfy <span>\(|G \cap D|\leq k\)</span> using <code class="language-plaintext highlighter-rouge">atMostKDislikes</code> and the
optimality condition \(\arg\max_{|X|+|G|}\) using <code class="language-plaintext highlighter-rouge">argMax(xg)</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="nv">invitees</span> <span class="k">=</span> <span class="o">{</span> <span class="nf">powerset</span><span class="o">(</span><span class="n">persons</span><span class="o">)</span> <span class="o">|</span> <span class="n">atMostKDislikes</span> <span class="k">_</span> <span class="o">}.</span><span class="py">argMax</span><span class="o">(</span><span class="n">xg</span><span class="o">)</span>
</code></pre></div></div>

<p>To complete the implementation, we need to output one valid solution if any
exist. If multiple possible solutions exist, we return one at random. Minimally
one solution will always exist, namely the empty set, so we can safily ask for
a random one.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Return a (valid) set of invitees at random.</span>
  <span class="nv">invitees</span><span class="o">.</span><span class="py">random</span><span class="o">.</span><span class="py">get</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This conclused the implementation of <span style="font-variant: small-caps;">Selecting Invitees (version 4)
</span>. Now we need to create some input on which it can run and to do that we use
the helper functions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">group</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>    <span class="c1">// Generate random group</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// The first 5 are liked</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>   <span class="c1">// The rest is disliked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(.</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// Autogenerate random like relations</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">group</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>
</code></pre></div></div>

<p>Then we simply evaluate <code class="language-plaintext highlighter-rouge">si4(.)</code> on this input.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">si4</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
</code></pre></div></div>
</div>

<div class="question-top"><div class="question" id="question-3"><div class="question-body"><div class="question-header">Question 10.3</div> <p>Try to play around with the ratios of people that are liked by the host and the
ratio of pairs that like eachother. Look at the visualization of the input and
see if you can find some interesting observations on the output.</p>
<div class="answer" id="question-.3-heading-1"><a onclick="document.getElementById('question-.3-answer-1').style.display = document.getElementById('question-.3-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.3-answer-1" style="display: none;"><p>Sorry, this is a trick question. It is very hard to find interesting patterns in
single observations, unless you are exploring edge cases. After we cover <span style="font-variant: small-caps;">Selecting Invitees (versions 5 and 6) </span>, will show how to analyze the
formalizations’ behaviour across many (different) inputs.</p>
</div></div>
</div></div></div>

<div class="question-top"><div class="question" id="question-4"><div class="question-body"><div class="question-header">Question 10.4</div> <p>In these simulations you can generate groups of any size. The simulation,
however, considers all possible subsets of people. How many possible subsets
exist given 3 people? The first person can be <em>in</em> or <em>out</em>, that’s two
options. The second person can also be <em>in</em> or <em>out</em>, that’s again two options,
but combined with the first thats \(2 \times 2\) options. The third person can
be <em>in</em> or <em>out</em> making \(2\times 2\times 2=8\) options. How many possible
subsets exist for 4 people? And for 8? and 15?</p>
</div></div></div>

<p>Keep in mind that the search space grows exponentially with the size of \(P\).
If your computer crashes or is taking a long time, you are probably trying to
simulate for large (\(&gt;10\)) groups.</p>

<p>From here on, you are free to explore the implementations of <span style="font-variant: small-caps;">Selecting Invitees (versions 5 and 6) </span> on your own. Try simulating some inputs
to get a feeling for the differences between the three formalizations. You can
even change the simulation code if you want. Perhaps try implementing any of the
other versions? After simulating the three models individually, we provide a
sandbox for you to compare their behaviour directly.</p>

<p><span class="problemtitle">Selecting invitees (version 5)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), and a function \(like: P \times P \rightarrow \{true, false\}\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|G\cap L| + |X| + |G|\) is maximized (where \(X = \{p_i,p_j \in G\}~|~like(p_i,p_j) = true \wedge i\neq j\}\)).</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="1000" data-layout="v45">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">si5</span><span class="o">(</span><span class="n">persons</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsLiked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsDisliked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="c1">// Input must satisfy these constraints, otherwise error.</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsLiked must be a subset of persons"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsDisliked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsDisliked must be a subset of persons"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">/\</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span>
          <span class="s">"personsLiked intersect personsDisliked must be emtpy"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">\/</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsLiked union personsLiked must equal persons"</span><span class="o">)</span>

  <span class="c1">// Specify the optimality condition.</span>
  <span class="k">def</span> <span class="nf">gl_x_g</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// The number of invitees the host likes.</span>
    <span class="k">val</span> <span class="nv">gl</span> <span class="k">=</span> <span class="o">(</span><span class="n">invitees</span> <span class="o">/\</span> <span class="n">personsLiked</span><span class="o">).</span><span class="py">size</span>              
    <span class="c1">// The number of unique pairs that like eachother.</span>
    <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="o">{</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">uniquePairs</span> <span class="o">|</span> <span class="nv">like</span><span class="o">.</span><span class="py">tupled</span> <span class="o">}.</span><span class="py">size</span>
    <span class="c1">// The number of total invitees.</span>
    <span class="k">val</span> <span class="nv">g</span>  <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">size</span>
    <span class="n">gl</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">g</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="nv">invitees</span> <span class="k">=</span> <span class="nf">powerset</span><span class="o">(</span><span class="n">persons</span><span class="o">).</span><span class="py">argMax</span><span class="o">(</span><span class="n">gl_x_g</span><span class="o">)</span>

  <span class="c1">// Return a (valid) set of invitees at random.</span>
  <span class="nv">invitees</span><span class="o">.</span><span class="py">random</span><span class="o">.</span><span class="py">get</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">group</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>    <span class="c1">// Generate random group</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// The first 5 are liked</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>   <span class="c1">// The rest is disliked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(.</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// Autogenerate random like relations</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">group</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>

<span class="nf">si5</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p><span class="problemtitle">Selecting invitees (version 6)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), a function \(like: P \times P \rightarrow \{true, false\}\), and a threshold value \(k\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|Y| \leq k\) and  \(|G\cap L|+|G|\) is maximized (where \(Y = \{p_i,p_j \in G\}~|~like(p_i,p_j) = false \wedge i\neq j \}\)).</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="1000" data-layout="v45">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">si6</span><span class="o">(</span><span class="n">persons</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsLiked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsDisliked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span>
        <span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="c1">// Input must satisfy these constraints, otherwise error.</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsLiked must be a subset of persons"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsDisliked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsDisliked must be a subset of persons"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">/\</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span>
          <span class="s">"personsLiked intersect personsDisliked must be emtpy"</span><span class="o">)</span>
  <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">\/</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="n">persons</span><span class="o">,</span>
          <span class="s">"personsLiked union personsLiked must equal persons"</span><span class="o">)</span>

	<span class="c1">// Specify that invitees is valid if |Y| &lt;= k.</span>
  <span class="k">def</span> <span class="nf">atMostKPairDislikes</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">{</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">uniquePairs</span> <span class="o">|</span> <span class="nv">like</span><span class="o">.</span><span class="py">tupled</span> <span class="o">}.</span><span class="py">size</span> <span class="o">&lt;=</span> <span class="n">k</span>
  <span class="o">}</span>

  <span class="c1">// Specify the optimality condition.</span>
  <span class="k">def</span> <span class="nf">gl_g</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// The number of invitees the host likes.  </span>
    <span class="k">val</span> <span class="nv">gl</span> <span class="k">=</span> <span class="o">(</span><span class="n">invitees</span> <span class="o">/\</span> <span class="n">personsLiked</span><span class="o">).</span><span class="py">size</span>
    <span class="c1">// The number of total invitees.</span>
    <span class="k">val</span> <span class="nv">g</span>  <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">size</span>       
    <span class="n">gl</span> <span class="o">+</span> <span class="n">g</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="nv">invitees</span> <span class="k">=</span> <span class="o">{</span> <span class="nf">powerset</span><span class="o">(</span><span class="n">persons</span><span class="o">)</span> <span class="o">|</span> <span class="n">atMostKPairDislikes</span> <span class="k">_</span> <span class="o">}.</span><span class="py">argMax</span><span class="o">(</span><span class="n">gl_g</span><span class="o">)</span>

  <span class="c1">// Return a (valid) set of invitees at random.</span>
  <span class="nv">invitees</span><span class="o">.</span><span class="py">random</span><span class="o">.</span><span class="py">get</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">group</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>    <span class="c1">// Generate random group</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// The first 5 are liked</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>   <span class="c1">// The rest is disliked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(.</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// Autogenerate random like relations</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">group</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>

<span class="nf">si6</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h3 id="analyzing-and-comparing-formalizations">Analyzing and comparing formalizations</h3>

<p>Simulations are a powerful tool to uncover consequences of formalization
choices, especially those that are hard to derive mathematically. However, the
full power of simulations is yet to be unlocked. Looking at single input
instances of single formalizations is not very informative and wouldn’t be worth
the effort of coding. Let’s see what we can learn about the three versions of <span style="font-variant: small-caps;">Selecting Invitees </span> by comparing them to eachother. We follow the
example questions from <a href="/lovelace/part_iii/simulating">Chapter 8</a>.</p>

<p>First we ask: <em>Are these formalizations truly different, or are they
equivalent?</em> We can run the simulation for all three versions on the same input
to compare their output. To prevent redundant copying, the implementations can
be found in <code class="language-plaintext highlighter-rouge">SelectingInvitees.si4(.)</code>, <code class="language-plaintext highlighter-rouge">SelectingInvitees.si5(.)</code> and <code class="language-plaintext highlighter-rouge">SelectingInvitees.si6(.)</code>.</p>

<div class="question-top"><div class="question" id="question-5"><div class="question-body"><div class="question-header">Question 10.5</div> <p>Using the code below, can you find input where two or more of the models give
the same output? If you find such input(s), what is it about them that leads to
equivalence?</p>
<div class="answer" id="question-.5-heading-1"><a onclick="document.getElementById('question-.5-answer-1').style.display = document.getElementById('question-.5-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.5-answer-1" style="display: none;"><p>Try defining input by hand instead of using the random generation first. For a
reminder, see <a href="/lovelace/part_iii/sim_subset_choice#supporting-code">Supporting code</a> in this chapter. If you find input for which the formalizations are equivalent, then try finding variations of that input that also lead to equivalence.</p>
</div></div>
</div></div></div>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="1000" data-layout="v25">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">group</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>    <span class="c1">// Generate random group</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// The first 5 are liked</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>   <span class="c1">// The rest is disliked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(.</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// Autogenerate random like relations</span>

<span class="k">val</span> <span class="nv">k</span> <span class="k">=</span> <span class="mi">2</span>

<span class="nf">println</span><span class="o">(</span><span class="s">"Output SI4: "</span> <span class="o">+</span> <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si4</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Output SI5: "</span> <span class="o">+</span> <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si5</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Output SI6: "</span> <span class="o">+</span> <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si6</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">group</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>
</code></pre></div></div>
</div>

<p>For some inputs the formalizations might be equivalent, but for many others they
are not. Next, try to answer the question: <em>How would you be able tell different
formalizations apart in terms of the behaviour that they predict?</em> Finally your
hard work will pay off, because you can use simulations to do this. The code
below consists of three steps: (1) generate a set of inputs, (2) compute for all
inputs the corresponding output using <code class="language-plaintext highlighter-rouge">si4</code>, <code class="language-plaintext highlighter-rouge">si5</code> and <code class="language-plaintext highlighter-rouge">si6</code>, (3)
perform data analysis and plotting.</p>

<p>For Step 1 and 3 some additional (helper) code is introduced. Step 1 introduces
code that generates input using the same helper functions we’ve already seen,
but at a larger scale (i.e., more inputs) and by giving control over input
properties. This is the <em>constrained input generator</em> (see <a href="/lovelace/part_iii/mathlib#simulation-architecture">Chapter
7</a>). In Step 3, we perform
an example analysis of the simulation data.</p>

<div class="question-top"><div class="question" id="question-6"><div class="question-body"><div class="question-header">Question 10.6</div> <p>Using the code below, what kind of differences can you find between the three
formal theories and when do you find them? Under what conditions do they
disappear?</p>
<div class="answer" id="question-.6-heading-1"><a onclick="document.getElementById('question-.6-answer-1').style.display = document.getElementById('question-.6-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.6-answer-1" style="display: none;"><p>You can manipulate parameters of the input generator to run analyses under
varying conditions. Remember that group sizes larger than 10 will most likely
not finish simulating before the end of the universe due to exponential growth
of the search space.</p>
</div></div>
</div></div></div>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="1000" data-layout="v30">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Generate inputs</span>
<span class="k">val</span> <span class="nv">inputData</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">SelectingInvitees.Input</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">inputGenerator</span><span class="o">(</span><span class="n">groupSize</span> <span class="k">=</span> <span class="mi">5</span><span class="o">,</span>
                                   <span class="n">likeDislikeRatio</span> <span class="k">=</span> <span class="o">.</span><span class="mi">2</span><span class="o">,</span>
                                   <span class="n">pairLikeRatio</span> <span class="k">=</span> <span class="o">.</span><span class="mi">4</span><span class="o">,</span>
                                   <span class="n">k</span> <span class="k">=</span> <span class="mi">2</span><span class="o">,</span>
                                   <span class="n">sampleSize</span> <span class="k">=</span> <span class="mi">50</span><span class="o">)</span>

<span class="c1">// Compute outputs</span>
<span class="k">val</span> <span class="nv">outputDataSI4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">inputData</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">input</span> <span class="k">=&gt;</span>
  <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si4</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsLiked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsDisliked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">k</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">outputDataSI5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">inputData</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">input</span> <span class="k">=&gt;</span>
  <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si5</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsLiked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsDisliked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">outputDataSI6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">inputData</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">input</span> <span class="k">=&gt;</span>
  <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si6</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsLiked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsDisliked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">k</span><span class="o">))</span>

<span class="c1">// Perform data analyses</span>
<span class="k">def</span> <span class="nf">analysis1</span><span class="o">(</span><span class="n">io</span><span class="k">:</span> <span class="o">(</span><span class="kt">SelectingInvitees.Input</span><span class="o">,</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]))</span><span class="k">:</span> <span class="o">(</span><span class="kt">Double</span><span class="o">,</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">input</span> <span class="k">=</span> <span class="nv">io</span><span class="o">.</span><span class="py">_1</span>
  <span class="k">val</span> <span class="nv">output</span> <span class="k">=</span> <span class="nv">io</span><span class="o">.</span><span class="py">_2</span>
  <span class="k">val</span> <span class="nv">nrLikes</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">.</span><span class="py">uniquePairs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">.</span><span class="py">tupled</span><span class="o">).</span><span class="py">size</span>
  <span class="k">val</span> <span class="nv">nrDislikes</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">.</span><span class="py">uniquePairs</span><span class="o">.</span><span class="py">filter</span><span class="o">(!</span><span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">.</span><span class="py">tupled</span><span class="o">(</span><span class="k">_</span><span class="o">)).</span><span class="py">size</span>
  <span class="k">val</span> <span class="nv">ldRatio</span> <span class="k">=</span> <span class="nv">nrLikes</span><span class="o">.</span><span class="py">toDouble</span> <span class="o">/</span> <span class="n">nrDislikes</span>
  <span class="k">val</span> <span class="nv">size</span> <span class="k">=</span> <span class="nv">output</span><span class="o">.</span><span class="py">size</span><span class="o">.</span><span class="py">doubleValue</span>
  <span class="o">(</span><span class="n">ldRatio</span><span class="o">,</span> <span class="n">size</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">dataAnalysis1SI4</span> <span class="k">=</span> <span class="o">(</span><span class="n">inputData</span> <span class="n">zip</span> <span class="n">outputDataSI4</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">analysis1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">dataAnalysis1SI5</span> <span class="k">=</span> <span class="o">(</span><span class="n">inputData</span> <span class="n">zip</span> <span class="n">outputDataSI5</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">analysis1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">dataAnalysis1SI6</span> <span class="k">=</span> <span class="o">(</span><span class="n">inputData</span> <span class="n">zip</span> <span class="n">outputDataSI6</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">analysis1</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">analysis2</span><span class="o">(</span><span class="n">io</span><span class="k">:</span> <span class="o">(</span><span class="kt">SelectingInvitees.Input</span><span class="o">,</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]))</span><span class="k">:</span> <span class="o">(</span><span class="kt">Double</span><span class="o">,</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">input</span> <span class="k">=</span> <span class="nv">io</span><span class="o">.</span><span class="py">_1</span>
  <span class="k">val</span> <span class="nv">output</span> <span class="k">=</span> <span class="nv">io</span><span class="o">.</span><span class="py">_2</span>
  <span class="k">val</span> <span class="nv">nrLikes</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">.</span><span class="py">uniquePairs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">.</span><span class="py">tupled</span><span class="o">).</span><span class="py">size</span>
  <span class="k">val</span> <span class="nv">nrDislikes</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">.</span><span class="py">uniquePairs</span><span class="o">.</span><span class="py">filter</span><span class="o">(!</span><span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">.</span><span class="py">tupled</span><span class="o">(</span><span class="k">_</span><span class="o">)).</span><span class="py">size</span>
  <span class="k">val</span> <span class="nv">ldRatio</span> <span class="k">=</span> <span class="nv">nrLikes</span><span class="o">.</span><span class="py">toDouble</span> <span class="o">/</span> <span class="n">nrDislikes</span>
  <span class="k">val</span> <span class="nv">avgLikes</span> <span class="k">=</span> <span class="nv">output</span><span class="o">.</span><span class="py">uniquePairs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">.</span><span class="py">tupled</span><span class="o">).</span><span class="py">size</span>
  <span class="o">(</span><span class="n">ldRatio</span><span class="o">,</span> <span class="n">avgLikes</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">dataAnalysis2SI4</span> <span class="k">=</span> <span class="o">(</span><span class="n">inputData</span> <span class="n">zip</span> <span class="n">outputDataSI4</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">analysis2</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">dataAnalysis2SI5</span> <span class="k">=</span> <span class="o">(</span><span class="n">inputData</span> <span class="n">zip</span> <span class="n">outputDataSI5</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">analysis2</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">dataAnalysis2SI6</span> <span class="k">=</span> <span class="o">(</span><span class="n">inputData</span> <span class="n">zip</span> <span class="n">outputDataSI6</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">analysis2</span><span class="o">)</span>

<span class="c1">// Plot analysis 1</span>
<span class="k">val</span> <span class="nv">trace14</span> <span class="k">=</span> <span class="nc">Trace</span><span class="o">(</span><span class="n">dataAnalysis1SI4</span><span class="o">,</span> <span class="s">"SI4"</span><span class="o">,</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Line</span><span class="o">).</span><span class="py">mean</span>
<span class="k">val</span> <span class="nv">trace15</span> <span class="k">=</span> <span class="nc">Trace</span><span class="o">(</span><span class="n">dataAnalysis1SI5</span><span class="o">,</span> <span class="s">"SI5"</span><span class="o">,</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Line</span><span class="o">).</span><span class="py">mean</span>
<span class="k">val</span> <span class="nv">trace16</span> <span class="k">=</span> <span class="nc">Trace</span><span class="o">(</span><span class="n">dataAnalysis1SI6</span><span class="o">,</span> <span class="s">"SI6"</span><span class="o">,</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Line</span><span class="o">).</span><span class="py">mean</span>

<span class="nc">Plot</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">trace14</span><span class="o">,</span> <span class="n">trace15</span><span class="o">,</span> <span class="n">trace16</span><span class="o">),</span>
     <span class="n">xAxisTitle</span> <span class="k">=</span> <span class="s">"pair-wise like/dislike ratio"</span><span class="o">,</span>
     <span class="n">yAxisTitle</span> <span class="k">=</span> <span class="s">"nr invitees"</span><span class="o">).</span><span class="py">render</span>

<span class="c1">// Plot analysis 2</span>
<span class="k">val</span> <span class="nv">trace24</span> <span class="k">=</span> <span class="nc">Trace</span><span class="o">(</span><span class="n">dataAnalysis2SI4</span><span class="o">,</span> <span class="s">"SI4"</span><span class="o">,</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Line</span><span class="o">).</span><span class="py">mean</span>
<span class="k">val</span> <span class="nv">trace25</span> <span class="k">=</span> <span class="nc">Trace</span><span class="o">(</span><span class="n">dataAnalysis2SI5</span><span class="o">,</span> <span class="s">"SI5"</span><span class="o">,</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Line</span><span class="o">).</span><span class="py">mean</span>
<span class="k">val</span> <span class="nv">trace26</span> <span class="k">=</span> <span class="nc">Trace</span><span class="o">(</span><span class="n">dataAnalysis2SI6</span><span class="o">,</span> <span class="s">"SI6"</span><span class="o">,</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Line</span><span class="o">).</span><span class="py">mean</span>

<span class="nc">Plot</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">trace24</span><span class="o">,</span> <span class="n">trace25</span><span class="o">,</span> <span class="n">trace26</span><span class="o">),</span>
    <span class="n">xAxisTitle</span> <span class="k">=</span> <span class="s">"pair-wise like/dislike ratio"</span><span class="o">,</span>
    <span class="n">yAxisTitle</span> <span class="k">=</span> <span class="s">"average likes among invitees"</span><span class="o">).</span><span class="py">render</span>
</code></pre></div></div>
</div>

<p>The analysis and plotting functionality within the online Scala system is quite
limited. If you want to explore the simulations more extensively consider
running the simulations in a dedicated Scala development environment (see
<a href="/lovelace/part_iii/simulating#installing-scala-and-mathlib">Installing Scala and <code class="language-plaintext highlighter-rouge">mathlib</code></a>) and
download the code here. You can also use the code block below and download the
raw data to perform analyses in your favorite statistical analysis software. The
code below might take longer to run as it simulates <span style="font-variant: small-caps;">Selecting Invitees
</span> for many more combinations of parameters. The resulting CSV file will also
be possibly large. Table 2 lists the CSV format.</p>

<p><label for="Table-ID2" class="margin-toggle"> ⊕</label><input type="checkbox" id="Table-ID2" class="margin-toggle" /><span class="marginnote">Table 2: CSV format for group size \(n\). </span></p>
<div class="table-wrapper" style="margin-top:3rem;">

  <table>
    <thead>
      <tr>
        <th style="text-align: left">column</th>
        <th style="text-align: center">type</th>
        <th style="text-align: left">description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: left">p0 .. pn</td>
        <td style="text-align: center">true/false</td>
        <td style="text-align: left">host likes pi</td>
      </tr>
      <tr>
        <td style="text-align: left">p0-p1 ..  pn-p(n-1)</td>
        <td style="text-align: center">true/false</td>
        <td style="text-align: left">pi and pj like each other</td>
      </tr>
      <tr>
        <td style="text-align: left">k</td>
        <td style="text-align: center">int</td>
        <td style="text-align: left">k value</td>
      </tr>
      <tr>
        <td style="text-align: left">p0-si4 .. pn-si4</td>
        <td style="text-align: center">true/false</td>
        <td style="text-align: left">pi is invited in si4</td>
      </tr>
      <tr>
        <td style="text-align: left">p0-si5 .. pn-si5</td>
        <td style="text-align: center">true/false</td>
        <td style="text-align: left">pi is invited in si5</td>
      </tr>
      <tr>
        <td style="text-align: left">p0-si6 .. pn-si6</td>
        <td style="text-align: center">true/false</td>
        <td style="text-align: left">pi is invited in si6</td>
      </tr>
    </tbody>
  </table>

</div>

<div class="table-wrapper" style="margin-top:3rem;">

</div>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="1000" data-layout="v30">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">groupSize</span> <span class="k">=</span> <span class="mi">6</span>
<span class="k">val</span> <span class="nv">likeDislikeRatios</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mf">0.22</span><span class="o">,</span> <span class="mf">0.66</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">pairLikeRatios</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mf">0.22</span><span class="o">,</span> <span class="mf">0.66</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ks</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mf">0.22</span><span class="o">,</span> <span class="mf">0.66</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">sampleSize</span> <span class="k">=</span> <span class="mi">1</span>

<span class="k">val</span> <span class="nv">inputData</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">SelectingInvitees.Input</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nf">for</span><span class="o">(</span><span class="n">likeDislikeRatio</span> <span class="k">&lt;-</span> <span class="n">likeDislikeRatios</span><span class="o">;</span>
      <span class="n">pairLikeRatio</span> <span class="k">&lt;-</span> <span class="n">pairLikeRatios</span><span class="o">;</span>
      <span class="n">k</span> <span class="k">&lt;-</span> <span class="n">ks</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
        <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">inputGenerator</span><span class="o">(</span>
          <span class="n">groupSize</span><span class="o">,</span>
          <span class="n">likeDislikeRatio</span><span class="o">,</span>
          <span class="n">pairLikeRatio</span><span class="o">,</span>
          <span class="o">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">groupSize</span><span class="o">).</span><span class="py">intValue</span><span class="o">,</span>
          <span class="n">sampleSize</span>
          <span class="o">)</span>
      <span class="o">}).</span><span class="py">toList</span><span class="o">.</span><span class="py">flatten</span>

<span class="c1">// Compute outputs</span>
<span class="k">val</span> <span class="nv">outputDataSI4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">inputData</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">input</span> <span class="k">=&gt;</span>
  <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si4</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsLiked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsDisliked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">k</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">outputDataSI5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">inputData</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">input</span> <span class="k">=&gt;</span>
  <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si5</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsLiked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsDisliked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">outputDataSI6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">inputData</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">input</span> <span class="k">=&gt;</span>
  <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si6</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsLiked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">personsDisliked</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">,</span>
                        <span class="nv">input</span><span class="o">.</span><span class="py">k</span><span class="o">))</span>

<span class="c1">// Safe data to CSV</span>
<span class="k">def</span> <span class="nf">inputHeader</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">SelectingInvitees.Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">groupList</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">.</span><span class="py">toList</span>
  <span class="k">val</span> <span class="nv">people</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="nv">groupList</span><span class="o">.</span><span class="py">indices</span><span class="o">)</span> <span class="k">yield</span> <span class="n">s</span><span class="s">"p$i"</span>
  <span class="k">val</span> <span class="nv">pairs</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="nv">groupList</span><span class="o">.</span><span class="py">indices</span><span class="o">;</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="nv">groupList</span><span class="o">.</span><span class="py">indices</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="k">yield</span> <span class="n">s</span><span class="s">"p$i-p$j"</span>
  <span class="nv">people</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">)</span> <span class="o">+</span> <span class="nv">pairs</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">)</span> <span class="o">+</span> <span class="s">"k"</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">outputHeader</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">SelectingInvitees.Input</span><span class="o">,</span> <span class="n">label</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">groupList</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">.</span><span class="py">toList</span>
  <span class="k">val</span> <span class="nv">people</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="nv">groupList</span><span class="o">.</span><span class="py">indices</span><span class="o">)</span> <span class="k">yield</span> <span class="n">s</span><span class="s">"p$i-$label"</span>
  <span class="nv">people</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">",\t"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">dataToCSV</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">SelectingInvitees.Input</span><span class="o">,</span> <span class="n">outputs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">groupList</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">group</span><span class="o">.</span><span class="py">toList</span>
  <span class="k">val</span> <span class="nv">hostLikes</span> <span class="k">=</span> <span class="nv">groupList</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">person</span> <span class="k">=&gt;</span> <span class="n">person</span> <span class="n">in</span> <span class="nv">input</span><span class="o">.</span><span class="py">personsLiked</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">likings</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">p1</span> <span class="k">&lt;-</span> <span class="n">groupList</span><span class="o">;</span> <span class="n">p2</span> <span class="k">&lt;-</span> <span class="n">groupList</span> <span class="k">if</span> <span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">)</span> <span class="k">yield</span> <span class="nv">input</span><span class="o">.</span><span class="py">like</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">k</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">k</span>
  <span class="k">val</span> <span class="nv">results</span> <span class="k">=</span> <span class="nv">outputs</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">output</span> <span class="k">=&gt;</span> <span class="nv">groupList</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="n">in</span> <span class="n">output</span><span class="o">).</span><span class="py">mkString</span><span class="o">(</span><span class="s">",\t"</span><span class="o">))</span>
  <span class="nv">hostLikes</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">)</span> <span class="o">+</span> <span class="nv">likings</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">)</span> <span class="o">+</span> <span class="nv">input</span><span class="o">.</span><span class="py">k</span>  <span class="o">+</span> <span class="nv">results</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">",\t"</span><span class="o">,</span> <span class="s">",\t"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">header</span> <span class="k">=</span> <span class="nf">inputHeader</span><span class="o">(</span><span class="nv">inputData</span><span class="o">.</span><span class="py">head</span><span class="o">)</span> <span class="o">+</span> <span class="s">",\t"</span> <span class="o">+</span>
  <span class="nf">outputHeader</span><span class="o">(</span><span class="nv">inputData</span><span class="o">.</span><span class="py">head</span><span class="o">,</span> <span class="s">"si4"</span><span class="o">)</span> <span class="o">+</span> <span class="s">",\t"</span> <span class="o">+</span>
  <span class="nf">outputHeader</span><span class="o">(</span><span class="nv">inputData</span><span class="o">.</span><span class="py">head</span><span class="o">,</span> <span class="s">"si5"</span><span class="o">)</span> <span class="o">+</span> <span class="s">",\t"</span> <span class="o">+</span>
  <span class="nf">outputHeader</span><span class="o">(</span><span class="nv">inputData</span><span class="o">.</span><span class="py">head</span><span class="o">,</span> <span class="s">"si6"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">rows</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="nv">inputData</span><span class="o">.</span><span class="py">indices</span><span class="o">)</span> <span class="k">yield</span>
  <span class="nf">dataToCSV</span><span class="o">(</span><span class="nf">inputData</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="nf">outputDataSI4</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="nf">outputDataSI5</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="nf">outputDataSI6</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>

<span class="k">val</span> <span class="nv">csv</span> <span class="k">=</span> <span class="n">header</span> <span class="o">+</span> <span class="s">"%0A"</span> <span class="o">+</span> <span class="nv">rows</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">"%0A"</span><span class="o">)</span>

<span class="nv">Fiddle</span><span class="o">.</span><span class="py">print</span><span class="o">(</span><span class="nf">a</span><span class="o">(</span><span class="n">href</span><span class="o">:=</span><span class="n">s</span><span class="s">"data:text/csv,$csv"</span><span class="o">,</span> <span class="n">target</span><span class="o">:=</span><span class="s">"_blank"</span><span class="o">,</span> <span class="nf">attr</span><span class="o">(</span><span class="s">"download"</span><span class="o">):=</span><span class="s">"data.csv"</span><span class="o">,</span> <span class="s">"Right click and Save link as..."</span><span class="o">))</span>
</code></pre></div></div>
</div>

<h3 id="references">References</h3>

<p>van Rooij, I., &amp; Baggio, G. (2021). <a href="https://journals.sagepub.com/doi/full/10.1177/1745691620970604">Theory before the test: How to build high-verisimilitude explanatory theories in psychological science.</a> <em>Perspectives on Psychological Science, 16</em>(4) 682–697.</p>


<div class="nav-wrapper">
	<div class="prev-chapter">
		
		<p><a href="/lovelace/part_iii/mathlib">Previous: Scala and mathlib</a></p>
		
	</div>
	<div class="next-chapter">
		
		<p><a href="/lovelace/part_iii/sim_coherence">Next: Coherence</a></p>
		
	</div>
</div>

    </article>
    <span class="print-footer">Subset choice - September 6, 2021 - Mark Blokpoel and Iris van Rooij</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    
      <li>
        <a href="mailto:m.blokpoel@donders.ru.nl">Mark
		<span class="icon-mail3"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.markblokpoel.com">
		<span class="icon-html-five"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.twitter.com/MarkBlokpoel">
		<span class="icon-twitter"></span>
		</a>
      </li>
    
      <li>
        <a href="//github.com/markblokpoel">
		<span class="icon-github"></span>
		</a>
      </li>
    
      <li>
        <a href="mailto:i.vanrooij@donders.ru.nl">Iris
		<span class="icon-mail3"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.irisvanrooijcogsci.com">
		<span class="icon-html-five"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.twitter.com/IrisVanRooij">
		<span class="icon-twitter"></span>
		</a>
      </li>
    
      <li>
        <a href="//github.com/IrisVanRooij">
		<span class="icon-github"></span>
		</a>
      </li>
      
  </ul>
<div class="credits">
<span>&copy; 2021 &nbsp;&nbsp;MARK BLOKPOEL AND IRIS VAN ROOIJ</span></br> <br>
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme</a> in <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>
  
<script>
  window.scalaFiddleTemplates = {

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }

  }
</script>

<script defer src='https://embed.scalafiddle.io/integration.js'></script>
</body>
</html>
