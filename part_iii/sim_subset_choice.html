<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Subset choice</title>
  <meta name="description" content="In this chapter you will learn how to use computer simulations as a theoreticaltool, namely to analyze the consequences different formalizations of verbalthe...">

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  


  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

 <!--   <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
  


  <link rel="stylesheet" type="text/css" href="/lovelace/css/tufte.css">
  <!-- <link rel="stylesheet" type="text/css" href="/lovelace/css/print.css" media="print"> -->

  <link rel="canonical" href="/lovelace/part_iii/sim_subset_choice">

  <link rel="alternate" type="application/rss+xml" title="THEORETICAL MODELING" href="/lovelace/feed.xml" />


  <!-- Embedding Script -->
  <script src="https://scastie.scala-lang.org/embedded.js"></script>

  <script>
  window.addEventListener('load', function() {
    scastie.Embedded('.simple');

    scastie.Embedded('.mathlib', {
    theme: 'light',
    isWorksheetMode: true,
    sbtConfig: 'libraryDependencies ++= Seq("com.markblokpoel" %% "mathlib" % "0.9.3", "com.markblokpoel" %% "mathlib-repo" % "0.1.5")',
    targetType: 'jvm',
    scalaVersion: '2.13.18'
    });
  });
  </script>

</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
	<div class="nav-wrapper">
	<div class="nav-left">
	<a href="/lovelace/"><img class="badge" src="/lovelace/assets/img/cover.png" alt="CH"></a>
	</div>
	<div class="nav-right">
	
		
  	
		
  	
		
		    
		      <a href="/lovelace/home">Home</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part1">I - Intro</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part2">II - Formalizing</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part3">III - Simulating</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/css/print.css"></a>
		    
	    
  	
		
  	
		
  	
	</div>
	</div>
	</nav>
</header>

    <article class="group">
      
<h1>Chapter 10 - Subset choice</h1>


<p>In this chapter you will learn how to use computer simulations as a theoretical
tool, namely to analyze the consequences different formalizations of verbal
theories. To reach that goal, you will also learn how to read an implementation
of formal theory in Scala <code class="language-plaintext highlighter-rouge">mathlib</code> (Blokpoel, 2024). At the end of this chapter, you will be
able to use (adapt and run) the provided simulation code to compare three formal
models of subset chocie. You will be able to test your intuitions about the theory and derive qualitative differences between them.</p>

<p>We pick up the conversation between Verbal and Formal from <a href="/lovelace/part_ii/subset#dialogue-1-formalizing-inviting-guests">Chapter 5 - Subset Choice</a>. Formal is very excited to share the computer simulations they implemented of the theoretical models Formal and Verbal created. Formal has some suggestions on how to use the simulations, which they explain to Verbal.</p>

<div class="indent-4 ">
  <p><strong>Formal:</strong> Welcome dr. Verbal! As promised, I have implemented computer simulations for three of our computational-level models.</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> That’s great. You said we can use the simulations to explore the models’ empirical implications. How does that work?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> The three formal models each make different tradeofs in optimizing selecting guests…</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> Yes, I remember. Shall I run some experiments to see which one is best?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> …wait! Before you leave me alone again for a few months, let’s do a bit more theory before the test (van Rooij &amp; Baggio, 2021). Do we even know if the models are different in important and meaningful ways? Even if they are different, are they so under sensible conditions?</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> But the formalizations are different, so the models must behave differently, right?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong>
Not necessarily. Formalizations that are different may behave the same or very similarly. Sometimes we can analytically derive such equivalence<label for="sn-id-equivalence" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-equivalence" class="margin-toggle" /><span class="sidenote">You can read about mathematically proving model equivalence in <a href="/lovelace/part_ii/coherence#Equivalence">Chapter 6 - Coherence</a>. </span> but this is not always easy. Computer simulations can come in handy.</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> Ah, I see. I would like to know if there are important differences between the theories. That way we can possibly rule out theories that cannot explain the phenomenon or find ways to revise them, just like when we were formalizing my verbal theories.</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> Indeed, that is the idea.</p>
</div>

<p>If you jumped here directly from <a href="/lovelace/part_ii/subset">Chapter 5 - Subset choice</a>
you may find it helpful to first read <a href="/lovelace/part_ii/mathlib">Chapter 9 - Scala and mathlib</a> to learn how to read (and write) Scala code using the <code class="language-plaintext highlighter-rouge">mathlib</code> library. In addition to the default <code class="language-plaintext highlighter-rouge">mathlib</code> library, the simulation code on this page includes supporting code which we explain first.</p>

<h2 id="supporting-code">Supporting code</h2>
<p>Running simulations requires input instances as specified by the theoretical model. While we could code input by hand, that is a lot of work. The benefit of using computer simulations is that with some clever coding we can automatically generate input. To that end, Formal has written supporting code. <label for="sn-id-helper" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-helper" class="margin-toggle" /><span class="sidenote">Supporting code is often written specifically for a domain. For example, a simulation of <a href="/lovelace/part_ii/coherence">Coherence</a> would require different support code. </span></p>

<p>For now, it is not important that you know how to write support code. However, in order to explore and adapt the code that Formal has provided, being able to use support code is recommended. Let’s explore some examples.</p>

<p>The theoretical models for selecting invitees (subset choice) take as input sets of persons and a function that for pairs of persons returns if they like eachother or not. The support code helps us generate these parts of the input.</p>

<h3 id="persons">Persons</h3>
<p>A particular person is identified by their name, and can be defined by using <code class="language-plaintext highlighter-rouge">Person(name: String)</code>. This function takes a string as input and returns a Person object with the given name:</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._

Person("Paola")
</pre>

<p>Persons with the same name are considered to be the same individual.</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._

val person1 = Person("Paola")
val person2 = Person("Paola")

person1 == person2
</pre>

<p>We can also generate random persons. Their names are randomly selected from a predefined list with 100 names based on the <a href="https://diversenamesgenerator.com/">Diverse Name Generator</a> (Maura, Williams &amp; Peng Lee, 2023). Running the code below multiple times will generate different persons.</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._

Person.random
</pre>

<p>We can also generate groups of <code class="language-plaintext highlighter-rouge">n</code> random individuals.</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._

Person.randomGroup(5)
</pre>

<p>These functions will help us create sets of persons. We can then use <code class="language-plaintext highlighter-rouge">mathlib</code> to work with these sets as expected. For example, we can create a set of random persons \(P\), randomly take 2 persons who are liked \(L\), and create a set of persons who are disliked \(D=P \setminus L\):</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._
import mathlib.set.SetTheory._

val persons = Person.randomGroup(5)
val personsLiked = persons.take(2)            // Take 2 people from persons.
val personsDisliked = persons \ personsLiked

personsLiked
personsDisliked
persons
</pre>

<h3 id="like-function">Like-function</h3>
<p>The final support code Formal provided is used to create like relationships between persons. In the formal model this function is defined as \(like: P\times P \rightarrow \{true,false\}\). After discussing with a colleague (see <a href="/lovelace/part_ii/subset#try-again">Exercise 4.4 in Chapter 5</a>), Formal recognized that the like function was intended to exclude reflection (i.e., self-liking) and is symmetrical \(like(a,b)=like(b,a)\) (i.e., it formalizes like or dislike <em>eachother</em>).<label for="sn-id-helper" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-helper" class="margin-toggle" /><span class="sidenote">The formalizations in this chapter are updated with these properties. </span></p>

<p>One could specify a like relationship manually. Simply create persons, store them in values so we can refer to them and then use <code class="language-plaintext highlighter-rouge">likes</code> or <code class="language-plaintext highlighter-rouge">dislikes</code> to create like relationships.</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._

val sanghan   = Person("Sanghan")
val youngJu   = Person("Young Ju")
val greny     = Person("Greny")

sanghan likes youngJu
sanghan dislikes greny
youngJu dislikes greny
</pre>

<p>Specifying a <em>complete</em> like function for a set of persons, however, will be quite a chore: for each pair you need to explicate if \(a\) likes \(b\) and vice versa. For \(10\) persons, that is a list of \(10 \cdot 10=100\) likes. Support functions help us here.</p>

<p>When given an incomplete list of like relationships, we can complete it this into a complete like function by assuming that any non-specified relationship is a dislike. Use the support function <code class="language-plaintext highlighter-rouge">.deriveLikeFunction(partialLikes: Set[Likes])</code> on a set of persons to create a like function for which the domain consists of all pairs of persons (including \((a,b)\), \((b,a)\) and \(a,a\)). It will complete <code class="language-plaintext highlighter-rouge">partialLikes</code> by assuming non-specified relationships are dislikes.</p>

<p>The <code class="language-plaintext highlighter-rouge">html</code> function is used to draw a graph of the like function. This graph is specified in the <a href="https://graphviz.org/doc/info/lang.html">DOT language</a> and can be generated using the <code class="language-plaintext highlighter-rouge">.toDotString(like)</code> helper function transforms persons and a like function to graph figures.</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._


val sanghan   = Person("Sanghan")
val youngJu   = Person("Young Ju")
val greny     = Person("Greny")

val persons = Set(sanghan, youngJu, greny)
val partialLikings = Set(sanghan likes youngJu, youngJu likes greny, youngJu dislikes sanghan)

def like = persons.deriveLikeFunction(partialLikings)

List(
  like(sanghan, youngJu),
  like(sanghan, greny),
  like(youngJu, greny)
)


html"&lt;img src=\"https://quickchart.io/graphviz?layout=circo&amp;graph=${persons.toDotString(like)}\" /&gt;"
</pre>

<p>While this approach is useful to manually explore small examples, it still is a lot of manual work. Wouldn’t it be nice if we can generate a complete like function randomly? Use the support function <code class="language-plaintext highlighter-rouge">.randomLikeFunction(probability: Double)</code> on a set of persons to create a random like function. For each pair (including \((a,b)\), \((b,a)\) and \(a,a\)), it generates <code class="language-plaintext highlighter-rouge">false</code> with probability equal to the ratio or true otherwise.</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._

val sanghan   = Person("Sanghan")
val youngJu   = Person("Young Ju")
val greny     = Person("Greny")

val persons = Set(sanghan, youngJu, greny)

def like = persons.randomLikeFunction(0.7)

List(
  like(sanghan, youngJu),
  like(sanghan, greny),
  like(youngJu, greny)
)

html"&lt;img src=\"https://quickchart.io/graphviz?layout=circo&amp;graph=${persons.toDotString(like)}\" /&gt;"
</pre>

<div class="question-top"><div class="question" id="question-1"><div class="question-body"><div class="question-header">Question 10.1</div> <p>What happens to the output of the like function when you change the probability?</p>
<div class="answer" id="question-1-heading-1"><a onclick="document.getElementById('question-1-answer-1').style.display = document.getElementById('question-1-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-1-answer-1" style="display: none;"><p>Try changing the probability value (the input of the function <code class="language-plaintext highlighter-rouge">randomLikeFunction</code>) and see what changes in the output.</p>
</div></div>
</div></div></div>

<p>A final example to illustrate how to generate a random input instance. An alternative visualization is used to indicate which persons are liked by the host or not. Note that generating a visualization graph with many persons will not display properly or potentially crash your browser due to the many relationships.</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._
import mathlib.set.SetTheory._

val persons = Person.randomGroup(5)
val personsLiked = persons.take(2)
val personsDisliked = persons \ personsLiked

def like = persons.randomLikeFunction(0.7)

html"&lt;img src=\"https://quickchart.io/graphviz?layout=circo&amp;graph=${persons.toDotString(personsLiked, personsDisliked, like)}\" /&gt;"
</pre>

<div class="question-top"><div class="question" id="question-2"><div class="question-body"><div class="question-header">Question 10.2</div> <p>With these support functions, we can randomly create instances for the formal models of selecting invitees. Why is this helpful?</p>
<div class="answer" id="question-.2-heading-1"><a onclick="document.getElementById('question-.2-answer-1').style.display = document.getElementById('question-.2-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.2-answer-1" style="display: none;"><p>It save a lot of manual work.</p>

<div class="question" id="question-2.0"><div class="question-body"><div class="question-header">Question 10.2.0</div> <p>Can you think of another use?</p>
<div class="answer" id="question-2.0-heading-1"><a onclick="document.getElementById('question-2.0-answer-1').style.display = document.getElementById('question-2.0-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-2.0-answer-1" style="display: none;"><p>You can compare model behaviour for the same input.</p>

<div class="question" id="question-2.0.0"><div class="question-body"><div class="question-header">Question 10.2.0.0</div> <p>Can you think of another use?</p>
<div class="answer" id="question-2.0.0-heading-1"><a onclick="document.getElementById('question-2.0.0-answer-1').style.display = document.getElementById('question-2.0.0-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-2.0.0-answer-1" style="display: none;"><p>You can generate different inputs at random and see if (and how) model behaviour changes as a function of the input.</p>

<div class="question" id="question-2.0.0.0"><div class="question-body"><div class="question-header">Question 10.2.0.0.0</div> <p>Can you think of another use?</p>
</div></div>
</div></div>
</div></div>
</div></div>
</div></div>
</div></div>
</div></div></div>

<h2 id="simulating-selecting-invitees">Simulating <span style="font-variant: small-caps; font-style: normal;">Selecting Invitees</span></h2>

<p>In this section we cover how to simulate <span class="problemtitle">Selecting invitees (version
4, 5 and 6) </span>. You will learn how to read Scala <code class="language-plaintext highlighter-rouge">mathlib</code> simulation code
and how it relates to the formalization. We go through <span class="problemtitle">Selecting
invitees (version 4) </span> step by step, after which you can explore versions 5 and
6 yourself. To make the code more readable, we use names in the code that are
more descriptive than the single letters used in math (see Table 1).</p>

<p><label for="Table-ID1" class="margin-toggle"> ⊕</label><input type="checkbox" id="Table-ID1" class="margin-toggle" /><span class="marginnote">Table 1: the mapping from math notation to Scala code. </span></p>
<div class="table-wrapper" style="margin-top:3rem;">

  <table>
    <thead>
      <tr>
        <th style="text-align: left">Math</th>
        <th style="text-align: left">Scala</th>
        <th style="text-align: left">Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: left">\(P\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">persons</code></td>
        <td style="text-align: left">Set of persons from which to select invitees.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(L\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">personsLiked</code></td>
        <td style="text-align: left">Subset of persons that is liked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(D\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">personsDisliked</code></td>
        <td style="text-align: left">Subset of persons that is disliked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(like\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">like</code></td>
        <td style="text-align: left">Function that captures if two persons like each other or not.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(k\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">k</code></td>
        <td style="text-align: left">Value that states how many of the invited persons at most can be disliked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(G\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">invitees</code></td>
        <td style="text-align: left">Set of invited persons.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(X\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">x</code></td>
        <td style="text-align: left">Set of all unique pairs of persons that like each other.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(Y\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">y</code></td>
        <td style="text-align: left">Set of all unique pairs of persons that dislike each other.</td>
      </tr>
    </tbody>
  </table>

</div>

<div class="stopandthink"><div class="st-header">Stop and think</div>
<p>Take a moment to familiarize yourself again with the
formalization. If you need more context, you can go back to <a href="/lovelace/part_ii/subset#">Chapter 5 - Subset
choice</a> where the formalization was introduced.</p>
</div>

<p><span class="problemtitle">Selecting invitees (version 4)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), a function \(like: P \times P \rightarrow \{true, false\}\), and a threshold value \(k\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|G\cap D| \leq k\) and \(|X| + |G|\) is maximized (where \(X = \{p_i,p_j \in G~|~like(p_i,p_j) = true \wedge i\neq j\}\)).</p>

<p>Let’s see how this formalization translates to simulation code. The
formalization is implemented in the <code class="language-plaintext highlighter-rouge">si4</code> function, all of the input (\(P\),
\(L\), \(D\), \(like\) and \(k\)) is listed as an argument of the function. The
type of the output also needs to be defined. In this case the output is a subset
\(G\subseteq P\) of persons, translating to the type <code class="language-plaintext highlighter-rouge">Set[Person]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">si4</span><span class="o">(</span>
  <span class="n">persons</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">personsLiked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">personsDisliked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span>
  <span class="n">k</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span>
</code></pre></div></div>

<p>The input in the formalization is subject to a few constraints. We check those
constraints in the code and stop the program with an informative error message
when the constraints are not met.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Input must satisfy these constraints, otherwise error.</span>
<span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span>
        <span class="s">"personsLiked must be a subset of persons"</span><span class="o">)</span>
<span class="nf">require</span><span class="o">(</span><span class="n">personsDisliked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span>
        <span class="s">"personsDisliked must be a subset of persons"</span><span class="o">)</span>
<span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">/\</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span>
        <span class="s">"personsLiked intersect personsDisliked must be emtpy"</span><span class="o">)</span>
<span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">\/</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="n">persons</span><span class="o">,</span>
        <span class="s">"personsLiked union personsLiked must equal persons"</span><span class="o">)</span>
</code></pre></div></div>

<p>The output is defined using two properties. To define output using the set
builder we write two functions that compute these properties. First, the host
wants to invite at most \(k\) people they dislike <span>\(|G \cap D|\leq
k\)</span>. The following function returns a Boolean if a given (sub)set of people does
not have this property.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Specify that invitees is valid if |G /\ D| &lt;= k.</span>
<span class="k">def</span> <span class="nf">atMostKDislikes</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">invitees</span> <span class="o">/\</span> <span class="n">personsDisliked</span><span class="o">).</span><span class="py">size</span> <span class="o">&lt;=</span> <span class="n">k</span>
</code></pre></div></div>

<p>Second, the formalization
states that the number of invited pairs that like each other plus the number of
invited people \(|X| + |G|\) is maximal. This is an optimality condition. The next
function computes for a given (sub)set of people, the set \(X\) and returns an
integer corresponding to \(|X| + |G|\).</p>

<p><label for="mn-id-tupled" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-id-tupled" class="margin-toggle" /><span class="marginnote">The <code class="language-plaintext highlighter-rouge">.tupled</code> function transforms a function
with \(n\) arguments into a function with 1 argument, where that argument is an
\(n\)-tuple. This is needed when applying a function on a set of tuples such as
<code class="language-plaintext highlighter-rouge">invitees.uniquePairs</code> that correspond to the arguments of that function. </span></p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Specify the optimality condition.</span>
<span class="k">def</span> <span class="nf">xg</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="c1">// The number of unique pairs that like eachother.</span>
  <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="o">{</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">uniquePairs</span> <span class="o">|</span> <span class="nv">like</span><span class="o">.</span><span class="py">tupled</span> <span class="o">}.</span><span class="py">size</span>
  <span class="c1">// The number of total invitees.</span>
  <span class="k">val</span> <span class="nv">g</span> <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">size</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">g</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Finally, we specify the set of possible valid outputs. Remember that for any given
formalization multiple possible outputs may exist that satisfy the output
conditions. Below, we consider all possible subsets of people, i.e., the powerset
\(\mathcal{P}(P)\). Any \(G\in\mathcal{P}(P)\) is a subset of people
\(G\subseteq P\). From this set of sets we build a set of sets of people that
satisfy <span>\(|G \cap D|\leq k\)</span> using <code class="language-plaintext highlighter-rouge">atMostKDislikes</code> and the
optimality condition \(\arg\max_{|X|+|G|}\) using <code class="language-plaintext highlighter-rouge">argMax(xg)</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">invitees</span> <span class="k">=</span> <span class="o">{</span> <span class="nf">powerset</span><span class="o">(</span><span class="n">persons</span><span class="o">)</span> <span class="o">|</span> <span class="n">atMostKDislikes</span> <span class="k">_</span> <span class="o">}.</span><span class="py">argMax</span><span class="o">(</span><span class="n">xg</span><span class="o">)</span>
</code></pre></div></div>

<p>To complete the implementation, we need to output one valid solution if any
exist. If multiple possible solutions exist, we return one at random. Minimally
one solution will always exist, namely the empty set, so we can safely ask for
a random one.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Return a (valid) set of invitees at random.</span>
<span class="nv">invitees</span><span class="o">.</span><span class="py">random</span><span class="o">.</span><span class="py">get</span>
</code></pre></div></div>

<p>This completes the implementation of <span class="problemtitle">Selecting Invitees (version 4)
</span>. Now we need to create some input for which <code class="language-plaintext highlighter-rouge">si4</code> can evaluate the output.</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._
import mathlib.set.SetTheory._

val group = Person.randomGroup(10)    // Generate random group
val personsLiked = group.take(5)      // The first 5 are liked
val personsDisliked = group.drop(5)   // The rest is disliked

def like = group.randomLikeFunction(.7) // Autogenerate random like relations

html"&lt;img src=\"https://quickchart.io/graphviz?layout=circo&amp;graph=${group.toDotString(personsLiked, personsDisliked, like)}\" /&gt;"

def si4(
  persons: Set[Person],
  personsLiked: Set[Person],
  personsDisliked: Set[Person],
  like: (Person, Person) =&gt; Boolean,
  k: Int
): Set[Person] = {
  // Input must satisfy these constraints, otherwise error.
  require(personsLiked &lt;= persons,
          "personsLiked must be a subset of persons")
  require(personsDisliked &lt;= persons,
          "personsDisliked must be a subset of persons")
  require(personsLiked /\ personsDisliked == Set.empty,
          "personsLiked intersect personsDisliked must be emtpy")
  require(personsLiked \/ personsDisliked == persons,
          "personsLiked union personsLiked must equal persons")

  // Specify that invitees is valid if |G /\ D| &lt;= k.
  def atMostKDislikes(invitees: Set[Person]): Boolean =
    (invitees /\ personsDisliked).size &lt;= k

  // Specify the optimality condition.
  def xg(invitees: Set[Person]): Int = {
    // The number of unique pairs that like eachother.
    val x = { invitees.uniquePairs | like.tupled }.size
    // The number of total invitees.
    val g = invitees.size
    x + g
  }

  val invitees = { powerset(persons) | atMostKDislikes _ }.argMax(xg)

  // Return a (valid) set of invitees at random.
  invitees.random.get

}

si4(
  persons = group,
  personsLiked,
  personsDisliked,
  like,
  k = 2
)
</pre>

<div class="question-top"><div class="question" id="question-3"><div class="question-body"><div class="question-header">Question 10.3</div> <p>Try to play around with the ratios of people that are liked by the host and the
ratio of pairs that like eachother. Look at the visualization of the input and
see if you can find some interesting observations on the output.</p>
<div class="answer" id="question-.3-heading-1"><a onclick="document.getElementById('question-.3-answer-1').style.display = document.getElementById('question-.3-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.3-answer-1" style="display: none;"><p>Sorry, this is a trick question. It is very hard to find interesting patterns in
single observations, unless you are exploring edge cases. After we cover <span class="problemtitle">Selecting Invitees (versions 5 and 6) </span>, will show how to analyze the
formalizations’ behaviour across many (different) inputs.</p>
</div></div>
</div></div></div>

<div class="question-top"><div class="question" id="question-4"><div class="question-body"><div class="question-header">Question 10.4</div> <p>In these simulations you can generate groups of any size. The simulation,
however, considers all possible subsets of people. How many possible subsets
exist given 3 people? The first person can be <em>in</em> or <em>out</em>, that’s two
options. The second person can also be <em>in</em> or <em>out</em>, that’s again two options,
but combined with the first thats \(2 \times 2\) options. The third person can
be <em>in</em> or <em>out</em> making \(2\times 2\times 2=8\) options. How many possible
subsets exist for 4 people? And for 8? and 15?</p>
</div></div></div>

<p>Keep in mind that the search space grows exponentially with the size of \(P\).
If your computer crashes or is taking a long time, you are probably trying to
simulate for large (\(&gt;10\)) groups.</p>

<p>From here on, you are free to explore the implementations of <span class="problemtitle">Selecting Invitees (versions 5 and 6) </span> on your own. Try simulating some inputs
to get a feeling for the differences between the three formalizations. You can
even change the simulation code if you want. Perhaps try implementing any of the
other versions? After simulating the three models individually, we provide a
sandbox for you to compare their behaviour directly.</p>

<p><span class="problemtitle">Selecting invitees (version 5)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), and a function \(like: P \times P \rightarrow \{true, false\}\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|G\cap L| + |X| + |G|\) is maximized (where \(X = \{p_i,p_j \in G\}~|~like(p_i,p_j) = true \wedge i\neq j\}\)).</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._
import mathlib.set.SetTheory._

def si5(
  persons: Set[Person],
  personsLiked: Set[Person],
  personsDisliked: Set[Person],
  like: (Person, Person) =&gt; Boolean
): Set[Person] = {

  // Input must satisfy these constraints, otherwise error.
  require(personsLiked &lt;= persons,
          "personsLiked must be a subset of persons")
  require(personsDisliked &lt;= persons,
          "personsDisliked must be a subset of persons")
  require(personsLiked /\ personsDisliked == Set.empty,
          "personsLiked intersect personsDisliked must be emtpy")
  require(personsLiked \/ personsDisliked == persons,
          "personsLiked union personsLiked must equal persons")

  // Specify the optimality condition.
  def gl_x_g(invitees: Set[Person]): Int = {
    // The number of invitees the host likes.
    val gl = (invitees /\ personsLiked).size
    // The number of unique pairs that like eachother.
    val x = { invitees.uniquePairs | like.tupled }.size
    // The number of total invitees.
    val g  = invitees.size
    gl + x + g
  }

  val invitees = powerset(persons).argMax(gl_x_g)

  // Return a (valid) set of invitees at random.
  invitees.random.get
}

val group = Person.randomGroup(10)    // Generate random group
val personsLiked = group.take(5)      // The first 5 are liked
val personsDisliked = group.drop(5)   // The rest is disliked

def like = group.randomLikeFunction(.7) // Autogenerate random like relations

html"&lt;img src=\"https://quickchart.io/graphviz?layout=circo&amp;graph=${group.toDotString(personsLiked, personsDisliked, like)}\" /&gt;"

si5(
  persons = group,
  personsLiked,
  personsDisliked,
  like
)
</pre>

<p><span class="problemtitle">Selecting invitees (version 6)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), a function \(like: P \times P \rightarrow \{true, false\}\), and a threshold value \(k\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|Y| \leq k\) and  \(|G\cap L|+|G|\) is maximized (where \(Y = \{p_i,p_j \in G\}~|~like(p_i,p_j) = false \wedge i\neq j \}\)).</p>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._
import mathlib.set.SetTheory._

def si6(
  persons: Set[Person],
  personsLiked: Set[Person],
  personsDisliked: Set[Person],
  like: (Person, Person) =&gt; Boolean,
  k: Int
): Set[Person] = {
  // Input must satisfy these constraints, otherwise error.
  require(personsLiked &lt;= persons,
          "personsLiked must be a subset of persons")
  require(personsDisliked &lt;= persons,
          "personsDisliked must be a subset of persons")
  require(personsLiked /\ personsDisliked == Set.empty,
          "personsLiked intersect personsDisliked must be emtpy")
  require(personsLiked \/ personsDisliked == persons,
          "personsLiked union personsLiked must equal persons")

	// Specify that invitees is valid if |Y| &lt;= k.
  def atMostKPairDislikes(invitees: Set[Person]): Boolean = {
    { invitees.uniquePairs | like.tupled }.size &lt;= k
  }

  // Specify the optimality condition.
  def gl_g(invitees: Set[Person]): Int = {
    // The number of invitees the host likes.
    val gl = (invitees /\ personsLiked).size
    // The number of total invitees.
    val g  = invitees.size
    gl + g
  }

  val invitees = { powerset(persons) | atMostKPairDislikes _ }.argMax(gl_g)

  // Return a (valid) set of invitees at random.
  invitees.random.get
}

val group = Person.randomGroup(10)    // Generate random group
val personsLiked = group.take(5)      // The first 5 are liked
val personsDisliked = group.drop(5)   // The rest is disliked

def like = group.randomLikeFunction(.7) // Autogenerate random like relations

html"&lt;img src=\"https://quickchart.io/graphviz?layout=circo&amp;graph=${group.toDotString(personsLiked, personsDisliked, like)}\" /&gt;"

si6(
  persons = group,
  personsLiked,
  personsDisliked,
  like,
  k = 2
)
</pre>

<h3 id="analyzing-and-comparing-formalizations">Analyzing and comparing formalizations</h3>

<p>Simulations are a useful theoretical tool to uncover consequences of formalization
choices, especially those that are hard to derive mathematically.
Looking at single input
instances of single formalizations is not very informative and wouldn’t be worth
the effort of coding. Let’s see what we can learn about the three versions of <span class="problemtitle">Selecting Invitees </span> by comparing them to eachother across many inputs.
We follow the example questions from <a href="/lovelace/part_iii/simulating">Chapter 8</a>.</p>

<p>First we ask: <em>Are these formalizations truly different, or are they
equivalent?</em> We can run the simulation for all three versions on the same input
to compare their output. To prevent redundant copying, the implementations can
be found in <code class="language-plaintext highlighter-rouge">SelectingInvitees.si4(.)</code>, <code class="language-plaintext highlighter-rouge">SelectingInvitees.si5(.)</code> and <code class="language-plaintext highlighter-rouge">SelectingInvitees.si6(.)</code>.</p>

<div class="question-top"><div class="question" id="question-5"><div class="question-body"><div class="question-header">Question 10.5</div> <p>Using the code below, can you find input where two or more of the models give
the same output? If you find such input(s), what is it about them that leads to
equivalence?</p>
<div class="answer" id="question-.5-heading-1"><a onclick="document.getElementById('question-.5-answer-1').style.display = document.getElementById('question-.5-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.5-answer-1" style="display: none;"><p>Try defining input by hand instead of using the random generation first. For a
reminder, see <a href="/lovelace/part_iii/sim_subset_choice#supporting-code">Supporting code</a> in this chapter. If you find input for which the formalizations are equivalent, then try finding variations of that input that also lead to equivalence.</p>
</div></div>
</div></div></div>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._
import mathlib.set.SetTheory._

val group = Person.randomGroup(10)    // Generate random group
val personsLiked = group.take(5)      // The first 5 are liked
val personsDisliked = group.drop(5)   // The rest is disliked

def like = group.randomLikeFunction(.7) // Autogenerate random like relations

val k = 2

html"&lt;img src=\"https://quickchart.io/graphviz?layout=circo&amp;graph=${group.toDotString(personsLiked, personsDisliked, like)}\" /&gt;"

val si4out = SelectingInvitees.si4(group, personsLiked, personsDisliked, like, k)
val si5out = SelectingInvitees.si5(group, personsLiked, personsDisliked, like)
val si6out = SelectingInvitees.si6(group, personsLiked, personsDisliked, like, k)

html"SI4: ${si4out.mkString("\t")}"
html"SI5: ${si5out.mkString("\t")}"
html"SI6: ${si6out.mkString("\t")}"
</pre>

<p>For some inputs the formalizations might be equivalent, but for many others they
are not. Next, try to answer the question: <em>How would you be able tell different
formalizations apart in terms of the input-output mappings they theorize?</em> Finally the
hard work will pay off, because you can use simulations to do this. The code
below consists of three steps: (1) generate a set of inputs, (2) compute for all
inputs the corresponding output using <code class="language-plaintext highlighter-rouge">si4</code>, <code class="language-plaintext highlighter-rouge">si5</code> and <code class="language-plaintext highlighter-rouge">si6</code>, (3)
perform data analysis and plotting.</p>

<p>For Step 1 and 3 some additional (helper) code is introduced. Step 1 introduces
code that generates input using the same helper functions we’ve already seen,
but at a larger scale (i.e., more inputs) and by giving control over input
properties. This is the <em>constrained input generator</em> (see <a href="/lovelace/part_iii/mathlib#simulation-architecture">Chapter
9</a>). In Step 3, we perform
an example analysis of the simulation data.</p>

<div class="question-top"><div class="question" id="question-6"><div class="question-body"><div class="question-header">Question 10.6</div> <p>Using the code below, what kind of differences can you find between the three
formal theories and when do you find them? Under what conditions do they
disappear?</p>
<div class="answer" id="question-.6-heading-1"><a onclick="document.getElementById('question-.6-answer-1').style.display = document.getElementById('question-.6-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.6-answer-1" style="display: none;"><p>You can manipulate parameters of the input generator to run analyses under
varying conditions. Remember that group sizes larger than 10 will most likely
not finish simulating before the end of the universe due to exponential growth
of the search space.</p>
</div></div>
</div></div></div>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._
import mathlib.set.SetTheory._

val inputs = Input.generate(
  groupSize         = 6,
  likeDislikeRatios = Set(0, 0.22, 0.66, 1.0),
  pairLikeRatios    = Set(0, 0.22, 0.66, 1.0),
  ks                = Set(0, 0.22, 0.66, 1.0),
  sampleSize        = 1
)

val io4 = inputs.map(input =&gt; input -&gt; SelectingInvitees.si4(
  input.group,
  input.personsLiked,
  input.personsDisliked,
  input.like,
  input.k
))
val io5 = inputs.map(input =&gt; input -&gt; SelectingInvitees.si5(
  input.group,
  input.personsLiked,
  input.personsDisliked,
  input.like
))
val io6 = inputs.map(input =&gt; input -&gt; SelectingInvitees.si6(
  input.group,
  input.personsLiked,
  input.personsDisliked,
  input.like,
  input.k
))

def analysis1(io: (Input, Set[Person])): (Double, Double) = {
  val input      = io._1
  val output     = io._2
  val nrLikes    = input.group.uniquePairs.count(input.like.tupled)
  val nrDislikes = input.group.uniquePairs.count(!input.like.tupled(_))
  val ldRatio    = nrLikes.toDouble / nrDislikes
  val size       = output.size.doubleValue
  (ldRatio, size)
}

val data4A1: List[(Double, Double)] = io4 map {
  case (i: Input, o: Set[Person]) =&gt; analysis1(i, o)
}
val data5A1: List[(Double, Double)] = io5 map {
  case (i: Input, o: Set[Person]) =&gt; analysis1(i, o)
}
val data6A1: List[(Double, Double)] = io6 map {
  case (i: Input, o: Set[Person]) =&gt; analysis1(i, o)
}

val data4string1 = Analyses.scatterDataToString(data4A1, "SI4")
val data5string1 = Analyses.scatterDataToString(data5A1, "SI5")
val data6string1 = Analyses.scatterDataToString(data6A1, "SI6")

html"&lt;img src=\"https://quickchart.io/chart?c={type:'scatter',data:{datasets:[$data4string1,$data5string1,$data6string1]},options:{scales:{xAxes:[{scaleLabel:{display: true,labelString:'like/dislike ratio'}}],yAxes:[{scaleLabel:{display:true,labelString:'size'}}]}}}\" /&gt;"
</pre>

<pre class="mathlib">
import mathlibrepo.selectinginvitees._
import mathlib.set.SetTheory._

val inputs = Input.generate(
  groupSize         = 6,
  likeDislikeRatios = Set(0, 0.22, 0.66, 1.0),
  pairLikeRatios    = Set(0, 0.22, 0.66, 1.0),
  ks                = Set(0, 0.22, 0.66, 1.0),
  sampleSize        = 1
)

val io4 = inputs.map(input =&gt; input -&gt; SelectingInvitees.si4(
  input.group,
  input.personsLiked,
  input.personsDisliked,
  input.like,
  input.k
))
val io5 = inputs.map(input =&gt; input -&gt; SelectingInvitees.si5(
  input.group,
  input.personsLiked,
  input.personsDisliked,
  input.like
))
val io6 = inputs.map(input =&gt; input -&gt; SelectingInvitees.si6(
  input.group,
  input.personsLiked,
  input.personsDisliked,
  input.like,
  input.k
))

def analysis2(io: (Input, Set[Person])): (Double, Double) = {
  val input      = io._1
  val output     = io._2
  val nrLikes    = input.group.uniquePairs.count(input.like.tupled)
  val nrDislikes = input.group.uniquePairs.count(!input.like.tupled(_))
  val ldRatio    = nrLikes.toDouble / nrDislikes
  val avgLikes   = output.uniquePairs.count(input.like.tupled)
  (ldRatio, avgLikes)
}

val data4A1: List[(Double, Double)] = io4 map {
  case (i: Input, o: Set[Person]) =&gt; analysis2(i, o)
}
val data5A1: List[(Double, Double)] = io5 map {
  case (i: Input, o: Set[Person]) =&gt; analysis2(i, o)
}
val data6A1: List[(Double, Double)] = io6 map {
  case (i: Input, o: Set[Person]) =&gt; analysis2(i, o)
}

val data4string1 = Analyses.scatterDataToString(data4A1, "SI4")
val data5string1 = Analyses.scatterDataToString(data5A1, "SI5")
val data6string1 = Analyses.scatterDataToString(data6A1, "SI6")

html"&lt;img src=\"https://quickchart.io/chart?c={type:'scatter',data:{datasets:[$data4string1,$data5string1,$data6string1]},options:{scales:{xAxes:[{scaleLabel:{display: true,labelString:'like/dislike ratio'}}],yAxes:[{scaleLabel:{display:true,labelString:'average likes'}}]}}}\" /&gt;"
</pre>

<p>The analysis and plotting functionality within the online Scala environment is quite
limited. If you want to explore the simulations more extensively consider
running the simulations in a dedicated Scala development environment. You can
download the code from the <a href="https://github.com/markblokpoel/mathlib-repo">mathlib-repo repository</a>.</p>

<h3 id="references">References</h3>

<p>Blokpoel, Mark (2024). mathlib: A Scala package for readable, verifiable and sustainable simulations of formal theory. Journal of Open Source Software, 9(99), 6049, <a href="https://doi.org/10.21105/joss.06049">https://doi.org/10.21105/joss.06049</a></p>

<p>O’Leary, Maura, Williams, Rainey, &amp; Peng Lee, Mario (2023). The Diverse Names Generator: An App for Decreasing Bias and Promoting Inclusion. In <em>Proceedings of the Linguistic Society of America 8</em>(1): 5541. <a href="https://doi.org/10.3765/plsa.v8i1.5541">https://doi.org/10.3765/plsa.v8i1.5541</a>.</p>

<p>van Rooij, Iris, &amp; Baggio, Giosuè (2021). <a href="https://journals.sagepub.com/doi/full/10.1177/1745691620970604">Theory before the test: How to build high-verisimilitude explanatory theories in psychological science.</a> <em>Perspectives on Psychological Science, 16</em>(4) 682–697.</p>


<div class="nav-wrapper">
	<div class="prev-chapter">
		
		<p><a href="/lovelace/part_iii/mathlib">Previous: Scala and mathlib</a></p>
		
	</div>
	<div class="next-chapter">
		
	</div>
</div>

    </article>
    <span class="print-footer">Subset choice - December 4, 2025 - Mark Blokpoel and Iris van Rooij</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    
      <li>
        <a href="mailto:m.blokpoel@donders.ru.nl">Mark
		<span class="icon-mail3"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.markblokpoel.com">
		<span class="icon-html-five"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.twitter.com/MarkBlokpoel">
		<span class="icon-twitter"></span>
		</a>
      </li>
    
      <li>
        <a href="//github.com/markblokpoel">
		<span class="icon-github"></span>
		</a>
      </li>
    
      <li>
        <a href="mailto:i.vanrooij@donders.ru.nl">Iris
		<span class="icon-mail3"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.irisvanrooijcogsci.com">
		<span class="icon-html-five"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.twitter.com/IrisVanRooij">
		<span class="icon-twitter"></span>
		</a>
      </li>
    
      <li>
        <a href="//github.com/IrisVanRooij">
		<span class="icon-github"></span>
		</a>
      </li>
      
  </ul>
<div class="credits">
<span>&copy; 2025 &nbsp;&nbsp;MARK BLOKPOEL AND IRIS VAN ROOIJ</span></br> <br>
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme</a> in <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>
  </body>
</html>
