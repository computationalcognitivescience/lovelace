<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Subset choice</title>
  <meta name="description" content="We pick up the conversation between Verbal and Formal from Chapter 4 - Subset Choice. Formal is very excited to share the computer simulations they implement...">

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  
  

  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

 <!--   <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
  


  <link rel="stylesheet" type="text/css" href="/lovelace/css/tufte.css">
  <!-- <link rel="stylesheet" type="text/css" href="/lovelace/css/print.css" media="print"> -->

  <link rel="canonical" href="http://localhost:4000/lovelace/part_iii/sim_subset_choice">

  <link rel="alternate" type="application/rss+xml" title="THEORETICAL MODELING" href="http://localhost:4000/lovelace/feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
	<div class="nav-wrapper">
	<div class="nav-left">
	<a href="/lovelace/"><img class="badge" src="/lovelace/assets/img/cover.png" alt="CH"></a>
	</div>
	<div class="nav-right">
	
		
  	
		
  	
		
		    
		      <a href="/lovelace/home">Home</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part1">I - Intro</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part2">II - Formalizing</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part3">III - Simulating</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part4">IV - Reflecting</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part5">V - Advanced</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/css/print.css"></a>
		    
	    
  	
		
  	
		
  	
	</div>
	</div>
	</nav>
</header>

    <article class="group">
      
<h1>Chapter 10 - Subset choice</h1>


<p>We pick up the conversation between Verbal and Formal from <a href="/lovelace/part_ii/subset#dialogue-1-formalizing-inviting-guests">Chapter 4 - Subset Choice</a>. Formal is very excited to share the computer simulations they implemented of the theoretical models Formal and Verbal created. Formal has some suggestions on how to use the simulations, which they explain to Verbal.</p>

<div class="indent-4 ">
  <p><strong>Formal:</strong> Welcome dr. Verbal! As promised, I have implemented computer simulations for three of our computational-level models.</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> That’s great. You said we can use the simulations to explore the models’ empirical implications. How does that work?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> The three formal models each make different tradeofs in optimizing selecting guests…</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> Yes, I remember. Shall I run some experiments to see which one is best?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> …wait! Before you leave me alone again for a few months, let’s do a bit more theory before the test. Do we even know if the models are different in important and meaningful ways? Even if they are different, are they so under sensible conditions?</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> But the formalisations are different, so the models must behave differently, right?</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong>
While the formalizations are different, it might be actually be possible that they behave the same or very similarly. Sometimes we can formally derive equivalence, but this is not always possible.<label for="sn-id-equivalence" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-equivalence" class="margin-toggle" /><span class="sidenote">You can read about mathematically proving model equivalence in <a href="/lovelace/part_ii/coherence#Equivalence">Chapter 5 - Coherence</a>. </span> In those cases, we can use computer simulations to explore the qualitative differences between theories.</p>
</div>

<div class="indent-0 ">
  <p><strong>Verbal:</strong> Ah, I would like to know if there are qualitative differences between the theories. I guess we can possibly rule out theories or find ways to update them, just like when we were formalizing my verbal theories.</p>
</div>

<div class="indent-4 ">
  <p><strong>Formal:</strong> Indeed, that is the idea.</p>
</div>

<p>If you jumped here directly from <a href="/lovelace/part_ii/subset">Chapter 4 - Subset choice</a>
you may find it helpful to first read <a href="/lovelace/part_ii/mathlib">Chapter 9 - Scala and mathlib</a> to learn how to read (and write) Scala code using the <code class="language-plaintext highlighter-rouge">mathlib</code> library. In addition to the default <code class="language-plaintext highlighter-rouge">mathlib</code> library, the simulation code on this page includes supporting code which we explain first.</p>

<h2 id="supporting-code">Supporting code</h2>
<p>Running simulations requires input instances as specified by the theoretical model. While we could code input by hand, that is a lot of work. The beauty of using computer simulations is that it can do the hard work for us by <em>automatically</em> generating input. To that end, Formal has written a supporting code. <label for="sn-id-helper" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-helper" class="margin-toggle" /><span class="sidenote">Supporting code is often written specifically for a domain. For example, <a href="/lovelace/part_iii/sim_coherence">simulating Coherence</a> uses different support code. </span></p>

<p>For now, it is not important that you know how to write support code. However, in order to explore and adapt the code that Formal has provided, being able to <em>use</em> support code is recommended. Let’s explore some examples. Remember that you can run (and adapt) the code in your browser using the <button style="background: rgba(255,255,255,0.6) !important;color: rgba(0, 0, 0, 0.6) !important;border-radius: 5px;border: 1px solid #ddd;font-family: Lato,'Helvetica Neue',Arial,Helvetica,sans-serif;font-size: 14px; padding: 3px 8px;transition: all 350ms ease;"><img src="https://embed.scalafiddle.io/runicon.png" style="padding: 0;margin: 0 0 4px 0;vertical-align: middle;width: 16px;height: 16px;display: inline;" />Run</button> button.</p>

<p>The theoretical models for selecting invitees (subset choice) take as input sets of persons and a function that for pairs of persons returns if they like eachother or not. The support code helps us generate these parts of the input.</p>

<h3 id="persons">Persons</h3>
<p>A particular person is identified by their name, and can be defined by using <code class="language-plaintext highlighter-rouge">Person(name: String)</code>. This function takes a string as input and returns a Person object with the given name:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Person</span><span class="o">(</span><span class="s">"Jamie"</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>Persons with the same name are considered to refer to the same individual, since the computer cannot distinguish between them.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">person1</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Jamie"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">person2</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Jamie"</span><span class="o">)</span>

<span class="n">person1</span> <span class="o">==</span> <span class="n">person2</span>
</code></pre></div></div>
</div>

<p>We can also create random persons. Their names are randomly selected from a predefined list with 100 names. Running the code below multiple times will create different persons.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Person</span><span class="o">.</span><span class="py">random</span>
</code></pre></div></div>
</div>

<p>We can also generate groups of <code class="language-plaintext highlighter-rouge">n</code> random individuals.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>These functions will help us create sets of persons. We can then use <code class="language-plaintext highlighter-rouge">mathlib</code> to work with these sets as expected. For example, we can create a set of random persons who are liked \(L\), a set of persons who are disliked \(D\), and the set of all persons \(P=L\cup D\):</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="n">persons</span> <span class="o">/\</span> <span class="n">personsLiked</span>

<span class="nf">println</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">personsDisliked</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">persons</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h3 id="like-function">Like-function</h3>
<p>The final support code Formal provided is used to create like relationships between persons. In the formal model this function is defined as \(like: P\times P \rightarrow \{true,false\}\). After discussing with a colleague (see <a href="/lovelace/part_ii/subset#try-again">Exercise X in Chapter 4</a>), Formal recognized that the like function was intended to exclude reflection (i.e., self-liking) and is symmetrical \(like(a,b)=like(b,a)\) (i.e., it formalises like or dislike <em>eachother</em>).<label for="sn-id-helper" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-helper" class="margin-toggle" /><span class="sidenote">The formalisations in this chapter are updated with these properties. </span></p>

<p>One could specify a like relationship manually. Simply create persons, store them in values so we can refer to them and then use <code class="language-plaintext highlighter-rouge">likes</code> or <code class="language-plaintext highlighter-rouge">dislikes</code> to create like relationships.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">lela</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lela"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">carlos</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Carlos"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ervin</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Ervin"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="n">lela</span> <span class="n">likes</span> <span class="n">carlos</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">carlos</span> <span class="n">dislikes</span> <span class="n">ervin</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">carlos</span> <span class="n">dislikes</span> <span class="n">lela</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>Specifying a <em>complete</em> like function for a set of persons, however, will be quite a chore: for each pair you need to explicate if \(a\) likes \(b\) and vice versa. For \(10\) persons, that is a list of \(10 \cdot 10=100\) likes. Support functions help us reduce this chore.</p>

<p>When given a partial specification of the like function, we can complete it by assuming that any non-specified relationship is a dislike. Use the support function <code class="language-plaintext highlighter-rouge">.deriveLikeFunction(partialLikes: Set[Likes])</code> on a set of persons to create a like function for which the domain consists of all pairs of persons (including \((a,b)\), \((b,a)\) and \(a,a\)). It will complete <code class="language-plaintext highlighter-rouge">partialLikes</code> by assuming non-specified relationships are dislikes.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-layout="v50">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">lela</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lela"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">carlos</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Carlos"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ervin</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Ervin"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">carlos</span><span class="o">,</span> <span class="n">ervin</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">partialLikings</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">lela</span> <span class="n">likes</span> <span class="n">carlos</span><span class="o">,</span> <span class="n">carlos</span> <span class="n">likes</span> <span class="n">ervin</span><span class="o">,</span><span class="n">carlos</span> <span class="n">dislikes</span> <span class="n">lela</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">deriveLikeFunction</span><span class="o">(</span><span class="n">partialLikings</span><span class="o">)</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">Viz.render()</code> function can draw graphs specified in the <a href="https://graphviz.org/doc/info/lang.html">DOT language</a>. The <code class="language-plaintext highlighter-rouge">.toDotString(like)</code> helper function transforms persons and a like function to graph figures.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">persons</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">like</span><span class="o">))</span>
</code></pre></div></div>
<p>And we can view the truth values associated with all pairs of persons.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">(</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">carlos</span><span class="o">),</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">ervin</span><span class="o">),</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">carlos</span><span class="o">,</span> <span class="n">ervin</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>
</div>

<p>While this approach is useful to manually explore small examples, it still is a lot of manual work. Wouldn’t it be nice if we can generate a complete like function randomly? Use the support function <code class="language-plaintext highlighter-rouge">.randomLikeFunction(probability: Double)</code> on a set of persons to create a random like function. For each pair (including \((a,b)\), \((b,a)\) and \(a,a\)), it generates <code class="language-plaintext highlighter-rouge">true</code> with probability equal to the ratio or false otherwise.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="700" data-layout="v50">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">lela</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lela"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">carlos</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Carlos"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ervin</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Ervin"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">carlos</span><span class="o">,</span> <span class="n">ervin</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(</span><span class="mf">0.7</span><span class="o">)</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">persons</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">like</span><span class="o">))</span>

<span class="nc">List</span><span class="o">(</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">carlos</span><span class="o">),</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">lela</span><span class="o">,</span> <span class="n">ervin</span><span class="o">),</span>
  <span class="nf">like</span><span class="o">(</span><span class="n">carlos</span><span class="o">,</span> <span class="n">ervin</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>
</div>

<div class="question" id="question-1"><p><em>Question 10.1:</em> What happens to the output of the like function when you change the probability?
<div class="answer" id="question-1-heading-1"><p><a onclick="document.getElementById('question-1-answer-1').style.display = document.getElementById('question-1-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a></p><div id="question-1-answer-1" style="display: none;"><p>Try changing the probability value (the input of the function ```randomLikeFunction```) and see what changes in the output.</p></div></div></p></div>

<p>A final example to illustrate how to generate a random input instance. An alternative visualization is used to indicate which persons are liked by the host or not. Note that generating a visualization graph with many persons will not display properly or potentially crash your browser due to the many relationships.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="700" data-layout="v20">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="n">persons</span> <span class="o">\</span> <span class="n">personsLiked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">persons</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(</span><span class="mf">0.7</span><span class="o">)</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">persons</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>
</code></pre></div></div>
</div>

<div class="question" id="question-2"><p><em>Question 10.2:</em> With these support functions, we can randomly create instances for the formal models of selecting invitees. Why is this helpful?
<div class="answer" id="question-2-heading-1"><p><a onclick="document.getElementById('question-2-answer-1').style.display = document.getElementById('question-2-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a></p><div id="question-2-answer-1" style="display: none;"><p>It save a lot of manual work.

<div class="question" id="question-3"><p><em>Question 10.3:</em> Can you think of another use?
<div class="answer" id="question-3-heading-1"><p><a onclick="document.getElementById('question-3-answer-1').style.display = document.getElementById('question-3-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a></p><div id="question-3-answer-1" style="display: none;"><p>You can compare model behaviour for the same input.

<div class="question" id="question-4"><p><em>Question 10.4:</em> Can you think of another use?
<div class="answer" id="question-4-heading-1"><p><a onclick="document.getElementById('question-4-answer-1').style.display = document.getElementById('question-4-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a></p><div id="question-4-answer-1" style="display: none;"><p>You can generate different inputs at random and see if (and how) model behaviour changes as a function of the input.

<div class="question" id="question-5"><p><em>Question 10.5:</em> Can you think of another use?</p></div></p></div></div></p></div></p></div></div></p></div></p></div></div></p></div>

<h2 id="simulating-selecting-invitees">Simulating <span style="font-variant: small-caps; font-style: normal;">Selecting Invitees</span></h2>

<p>In this section we simulate <span style="font-variant: small-caps;">Selecting invitees (version 4, 5 and 6) </span>. Each of the models is copied here, for your convenience. To make the code more readable, we use names in the code that are more descriptive than the single letters used in math (see Table 1).</p>

<p><label for="Table-ID1" class="margin-toggle"> ⊕</label><input type="checkbox" id="Table-ID1" class="margin-toggle" /><span class="marginnote">Table 1: the mapping from math notation to Scala code. </span></p>
<div class="table-wrapper" style="margin-top:3rem;">

  <table>
    <thead>
      <tr>
        <th style="text-align: left">Math</th>
        <th style="text-align: left">Scala</th>
        <th style="text-align: left">Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: left">\(P\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">persons</code></td>
        <td style="text-align: left">Set of persons from which to select invitees.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(L\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">personsLiked</code></td>
        <td style="text-align: left">Subset of persons that is liked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(D\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">personsDisliked</code></td>
        <td style="text-align: left">Subset of persons that is disliked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(like\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">like</code></td>
        <td style="text-align: left">Function that captures if two persons like each other or not.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(k\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">k</code></td>
        <td style="text-align: left">Value that states how many of the invited persons at most can be disliked.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(G\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">invitees</code></td>
        <td style="text-align: left">Set of invited persons.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(X\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">x</code></td>
        <td style="text-align: left">Set of all unique pairs of persons that like each other.</td>
      </tr>
      <tr>
        <td style="text-align: left">\(Y\)</td>
        <td style="text-align: left"><code class="language-plaintext highlighter-rouge">y</code></td>
        <td style="text-align: left">Set of all unique pairs of persons that dislike each other.</td>
      </tr>
    </tbody>
  </table>

</div>

<p>From here on, you are free to explore the simulations at your own. Try to get a feeling for how the three formalizations behave. You can even change the simulation code if you want. After simulating the three models individually, we provide a sandbox for you to compare their behaviour directly.</p>

<p><span class="problemtitle">Selecting invitees (version 4)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), a function \(like: P \times P \rightarrow \{true, false\}\), and a threshold value \(k\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|G\cap D| \leq k\) and \(|X| + |G|\) is maximized (where \(X = \{p_i,p_j \in G~|~like(p_i,p_j) = true \wedge i\neq j\}\)).</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">si4</span><span class="o">(</span><span class="n">persons</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsLiked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsDisliked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span>
        <span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

    <span class="c1">// Input must satisfy these constraints, or program halts.</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"personsLiked must be a subset of persons"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsDisliked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"personsDisliked must be a subset of persons"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">/\</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="s">"intersection between personsLiked and personsDisliked must be emtpy"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">\/</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"union of personsLiked and personsLiked must equal persons"</span><span class="o">)</span>

    <span class="c1">// Specify that invitees is valid if |G /\ D| &lt;= k.</span>
    <span class="k">def</span> <span class="nf">atMostKDislikes</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> 
        <span class="o">(</span><span class="n">invitees</span> <span class="o">/\</span> <span class="n">personsDisliked</span><span class="o">).</span><span class="py">size</span> <span class="o">&lt;=</span> <span class="n">k</span>
    
    <span class="c1">// Specify the optimality condition.</span>
    <span class="k">def</span> <span class="nf">xg</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">uniquePairs</span> <span class="c1">// From all pairs of invitees,</span>
                <span class="o">.</span><span class="py">build</span><span class="o">(</span><span class="nv">like</span><span class="o">.</span><span class="py">tupled</span><span class="o">)</span>  <span class="c1">// select all pairs that like each other,</span>
                <span class="o">.</span><span class="py">size</span>                <span class="c1">// and count them.</span>
        <span class="k">val</span> <span class="nv">g</span> <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">size</span>        <span class="c1">// Count the number of total invitees.</span>
        <span class="n">x</span> <span class="o">+</span> <span class="n">g</span>
    <span class="o">}</span>
    
    <span class="k">val</span> <span class="nv">invitees</span> <span class="k">=</span> <span class="nf">powerset</span><span class="o">(</span><span class="n">persons</span><span class="o">)</span>  <span class="c1">// From all possible subsets of persons,</span>
        <span class="o">.</span><span class="py">build</span><span class="o">(</span><span class="n">atMostKDislikes</span><span class="o">)</span>       <span class="c1">// select subsets that contain at most k disliked persons,</span>
        <span class="o">.</span><span class="py">argMax</span><span class="o">(</span><span class="n">xg</span><span class="o">)</span>                   <span class="c1">// and select the subsets that maximize the optimality condition.</span>
    
    <span class="c1">// If more than one solution exists, return one at random. Always 1 solution must exist,</span>
    <span class="c1">// because the empty set is a valid solution. Hence, we can assume random does not</span>
    <span class="c1">// return None and 'get' the value.</span>
    <span class="nv">invitees</span><span class="o">.</span><span class="py">random</span><span class="o">.</span><span class="py">get</span> 
<span class="o">}</span>

<span class="k">val</span> <span class="nv">group</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>    <span class="c1">// Generate random group</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// The first 5 are liked</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>   <span class="c1">// The rest is disliked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(.</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// Autogenerate random like relations</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">group</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>

<span class="nf">si4</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p><span class="problemtitle">Selecting invitees (version 5)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), and a function \(like: P \times P \rightarrow \{true, false\}\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|G\cap L| + |X| + |G|\) is maximized (where \(X = \{p_i,p_j \in G\}~|~like(p_i,p_j) = true \wedge i\neq j\}\)).</p>

<div data-scalafiddle="" data-template="Mathlib" data-theme="light" data-minheight="1000" data-layout="v45">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">si5</span><span class="o">(</span><span class="n">persons</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsLiked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsDisliked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
		
    <span class="c1">// Input must satisfy these constraints, or program halts.</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"personsLiked must be a subset of persons"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsDisliked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"personsDisliked must be a subset of persons"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">/\</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="s">"intersection between personsLiked and personsDisliked must be emtpy"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">\/</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"union of personsLiked and personsLiked"</span><span class="o">)</span>
	
    <span class="c1">// Specify the optimality condition.</span>
    <span class="k">def</span> <span class="nf">gl_x_g</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">gl</span> <span class="k">=</span> <span class="o">(</span><span class="n">invitees</span> <span class="o">/\</span> <span class="n">personsLiked</span><span class="o">)</span>
    	         <span class="o">.</span><span class="py">size</span>                <span class="c1">// Count the invitees the host likes.</span>
        <span class="k">val</span> <span class="nv">x</span>  <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">uniquePairs</span> <span class="c1">// From all pairs of invitees,</span>
                 <span class="o">.</span><span class="py">build</span><span class="o">(</span><span class="nv">like</span><span class="o">.</span><span class="py">tupled</span><span class="o">)</span>  <span class="c1">// select all pairs that like each other,</span>
                 <span class="o">.</span><span class="py">size</span>                <span class="c1">// and count them.</span>
        <span class="k">val</span> <span class="nv">g</span>  <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">size</span>        <span class="c1">// Count the number of total invitees.</span>
        <span class="n">gl</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">g</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="nv">invitees</span> <span class="k">=</span> <span class="nf">powerset</span><span class="o">(</span><span class="n">persons</span><span class="o">)</span>  <span class="c1">// From all possible subsets of persons,</span>
        <span class="o">.</span><span class="py">argMax</span><span class="o">(</span><span class="n">gl_x_g</span><span class="o">)</span>               <span class="c1">// select those that maximize |G/\L| + |X| + |G|</span>
    
    <span class="c1">// If more than one solution exists, return one at random. Always 1 solution must exist,</span>
    <span class="c1">// because the empty set is a valid solution. Hence, we can assume random does not</span>
    <span class="c1">// return None and 'get' the value.</span>
    <span class="nv">invitees</span><span class="o">.</span><span class="py">random</span><span class="o">.</span><span class="py">get</span> 
<span class="o">}</span>

<span class="k">val</span> <span class="nv">group</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>    <span class="c1">// Generate random group</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// The first 5 are liked</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>   <span class="c1">// The rest is disliked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(.</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// Autogenerate random like relations</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">group</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>

<span class="nf">si5</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p><span class="problemtitle">Selecting invitees (version 6)</span><br /><span class="probleminout">Input:</span> A set \(P\), subsets \(L \subseteq P\) and \(D \subseteq P\) with \(L \cap D = \emptyset\) and \(L \cup D = P\), a function \(like: P \times P \rightarrow \{true, false\}\), and a threshold value \(k\).<br /><span class="probleminout">Output:</span> 
\(G \subseteq P\) such that \(|Y| \leq k\) and  \(|G\cap L|+|G|\) is maximized (where \(Y = \{p_i,p_j \in G\}~|~like(p_i,p_j) = false \wedge i\neq j \}\)).</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="1000" data-layout="v45">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">si6</span><span class="o">(</span><span class="n">persons</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsLiked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">personsDisliked</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span>
        <span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    
    <span class="c1">// Input must satisfy these constraints, or program halts.</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"personsLiked must be a subset of persons"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsDisliked</span> <span class="o">&lt;=</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"personsDisliked must be a subset of persons"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">/\</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="s">"intersection between personsLiked and personsDisliked must be emtpy"</span><span class="o">)</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">personsLiked</span> <span class="o">\/</span> <span class="n">personsDisliked</span> <span class="o">==</span> <span class="n">persons</span><span class="o">,</span> <span class="s">"union of personsLiked and personsLiked"</span><span class="o">)</span>

	<span class="c1">// Specify that invitees is valid if |Y| &lt;= k.</span>
    <span class="k">def</span> <span class="nf">atMostKPairDislikes</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> 
      <span class="o">{</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">uniquePairs</span> <span class="o">|</span> <span class="nv">like</span><span class="o">.</span><span class="py">tupled</span> <span class="o">}.</span><span class="py">size</span> <span class="o">&lt;=</span> <span class="n">k</span>
		
    <span class="c1">// Specify the optimality condition.</span>
    <span class="k">def</span> <span class="nf">gl_g</span><span class="o">(</span><span class="n">invitees</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">gl</span> <span class="k">=</span> <span class="o">(</span><span class="n">invitees</span> <span class="o">/\</span> <span class="n">personsLiked</span><span class="o">)</span>
    	         <span class="o">.</span><span class="py">size</span>                <span class="c1">// Count the invitees the host likes.</span>
        <span class="k">val</span> <span class="nv">g</span>  <span class="k">=</span> <span class="nv">invitees</span><span class="o">.</span><span class="py">size</span>        <span class="c1">// Count the number of total invitees.</span>
        <span class="n">gl</span> <span class="o">+</span> <span class="n">g</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="nv">invitees</span> <span class="k">=</span> <span class="o">{</span> <span class="nf">powerset</span><span class="o">(</span><span class="n">persons</span><span class="o">)</span> <span class="o">|</span> <span class="n">atMostKPairDislikes</span> <span class="k">_</span> <span class="o">}</span>
                   <span class="o">.</span><span class="py">argMax</span><span class="o">(</span><span class="n">gl_g</span><span class="o">)</span>
    
    <span class="c1">// If more than one solution exists, return one at random. Always 1 solution must exist,</span>
    <span class="c1">// because the empty set is a valid solution. Hence, we can assume random does not</span>
    <span class="c1">// return None and 'get' the value.</span>
    <span class="nv">invitees</span><span class="o">.</span><span class="py">random</span><span class="o">.</span><span class="py">get</span> 
<span class="o">}</span>

<span class="k">val</span> <span class="nv">group</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>    <span class="c1">// Generate random group</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// The first 5 are liked</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>   <span class="c1">// The rest is disliked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(.</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// Autogenerate random like relations</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">group</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>

<span class="nf">si6</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h3 id="comparing-model-behaviour">Comparing model behaviour</h3>

<p>Work in progress.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light" data-minheight="1000" data-layout="v30">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">group</span> <span class="k">=</span> <span class="nv">Person</span><span class="o">.</span><span class="py">randomGroup</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>    <span class="c1">// Generate random group</span>
<span class="k">val</span> <span class="nv">personsLiked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// The first 5 are liked</span>
<span class="k">val</span> <span class="nv">personsDisliked</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>   <span class="c1">// The rest is disliked</span>

<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">group</span><span class="o">.</span><span class="py">randomLikeFunction</span><span class="o">(.</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// Autogenerate random like relations</span>

<span class="k">val</span> <span class="nv">k</span> <span class="k">=</span> <span class="mi">2</span>

<span class="nv">Viz</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">group</span><span class="o">.</span><span class="py">toDotString</span><span class="o">(</span><span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>

<span class="nf">println</span><span class="o">(</span><span class="s">"Output SI4: "</span> <span class="o">+</span> <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si4</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Output SI5: "</span> <span class="o">+</span> <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si5</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Output SI6: "</span> <span class="o">+</span> <span class="nv">SelectingInvitees</span><span class="o">.</span><span class="py">si6</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">personsLiked</span><span class="o">,</span> <span class="n">personsDisliked</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span>
</code></pre></div></div>
</div>



<div class="nav-wrapper">
	<div class="prev-chapter">
		
		<p><a href="/lovelace/part_iii/mathlib">Previous: Scala and mathlib</a></p>
		
	</div>
	<div class="next-chapter">
		
		<p><a href="/lovelace/part_iii/sim_coherence">Next: Coherence</a></p>
		
	</div>
</div>

    </article>
    <span class="print-footer">Subset choice - April 30, 2021 - Mark Blokpoel and Iris van Rooij</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    
      <li>
        <a href="mailto:m.blokpoel@donders.ru.nl">Mark
		<span class="icon-mail3"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.markblokpoel.com">
		<span class="icon-html-five"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.twitter.com/MarkBlokpoel">
		<span class="icon-twitter"></span>
		</a>
      </li>
    
      <li>
        <a href="//github.com/markblokpoel">
		<span class="icon-github"></span>
		</a>
      </li>
    
      <li>
        <a href="mailto:i.vanrooij@donders.ru.nl">Iris
		<span class="icon-mail3"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.irisvanrooijcogsci.com">
		<span class="icon-html-five"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.twitter.com/IrisVanRooij">
		<span class="icon-twitter"></span>
		</a>
      </li>
    
      <li>
        <a href="//github.com/IrisVanRooij">
		<span class="icon-github"></span>
		</a>
      </li>
      
  </ul>
<div class="credits">
<span>&copy; 2021 &nbsp;&nbsp;MARK BLOKPOEL AND IRIS VAN ROOIJ</span></br> <br>
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme</a> in <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>
  
<script>
  window.scalaFiddleTemplates = {

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'Mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._ \nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://unpkg.com/vis-network/standalone/umd/\',\n\t\t    paths: {\n\t\t\t  "vis": "vis-network.min"\n\t\t    }\n\t\t  });\n\n\t    require(["vis"], function(vis) {\n  \t\t  const dotString = \'${dot}\';\n\t\t  var parsedData = vis.parseDOTNetwork(dotString);\n\t\t  var data = {\n\t\t\t  nodes: parsedData.nodes,\n\t\t\t  edges: parsedData.edges\n\t\t\t}\n\t\t  var options = parsedData.options;\n  \t\t  var container = document.getElementById(\'plot$vizCounter\');\n\t\t  var network = new vis.Network(container, data, options);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'http://webgraphviz.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\n\n \nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n    \n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n        \n        rg(size, names)\n    }\n\t\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\t\t\t\t\t\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\t\t\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\t\t\t\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\t\t\t\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\t\t\t\n\t\t\tlike \n\t\t}\n\t\t\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t\t\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else \n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean = \n        (invitees /\\ personsDisliked).size <= k\n    \n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n    \n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\t\t\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\t\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n\t\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    \n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean = \n      { invitees.uniquePairs | like.tupled }.size <= k\n\t\t\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n    \n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get \n}\n}\n\nimport Person._ \nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@1.58.4/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n} \nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }

  }
</script>

<script defer src='https://embed.scalafiddle.io/integration.js'></script>
</body>
</html>
