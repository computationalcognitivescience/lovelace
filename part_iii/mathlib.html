<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Scala and mathlib</title>
  <meta name="description" content="Learning how to read and write code is quite similar to learning how to use mathto formalise verbal theories. In this chapter we cover the basics of coding i...">

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  
  

  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

 <!--   <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
  


  <link rel="stylesheet" type="text/css" href="/lovelace/css/tufte.css">
  <!-- <link rel="stylesheet" type="text/css" href="/lovelace/css/print.css" media="print"> -->

  <link rel="canonical" href="http://localhost:4000/lovelace/part_iii/mathlib">

  <link rel="alternate" type="application/rss+xml" title="THEORETICAL MODELING" href="http://localhost:4000/lovelace/feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
	<div class="nav-wrapper">
	<div class="nav-left">
	<a href="/lovelace/"><img class="badge" src="/lovelace/assets/img/cover.png" alt="CH"></a>
	</div>
	<div class="nav-right">
	
		
  	
		
  	
		
		    
		      <a href="/lovelace/home">Home</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part1">I - Intro</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part2">II - Formalizing</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part3">III - Simulating</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/content/part4">IV - Advanced Topics</a>
		    
	    
  	
		
		    
		      <a href="/lovelace/css/print.css"></a>
		    
	    
  	
		
  	
		
  	
	</div>
	</div>
	</nav>
</header>

    <article class="group">
      
<h1>Chapter 9 - Scala and mathlib</h1>


<p>Learning how to read and write code is quite similar to learning how to use math
to formalise verbal theories. In this chapter we cover the basics of coding in
Scala and <code class="language-plaintext highlighter-rouge">mathlib</code>. Understanding Scala code might seem daunting at first,
but you have already mastered a more difficult skill: Translating verbal theory
(which is underspecified) to formal, mathematical characterizations. Translating
from formalizations to simulation code requires understanding Scala, but it is
easier in the sense that there is much less ambiguity to deal with.</p>

<p>At the end of this chapter you will be able to understand how concepts from
<a href="/lovelace/part_i/math">Chapter 3 - Math concepts and notation</a> can be
translated to Scala code. The chapter is quite detailed and we recommend to use
it as a reference guide when reading chapters on simulations or when writing
your own code. The <a href="/lovelace/part_iii/mathlib#cheat-sheet">cheat sheet</a> down
below provides a helpful overview.</p>

<h2 id="scala-fundamentals">Scala fundamentals</h2>
<p>We cover only a small subset of the full Scala language here. This subset
suffices for implementing basic simulations of formal theories. If after reading
this chapter you want to learn more about Scala, there are various textbooks
(e.g. Odersky, Spoon and Venners, 2019; but see also <a href="https://docs.scala-lang.org/books.html">Scala books</a>) and online resources such as the official
<a href="https://docs.scala-lang.org/tour/tour-of-scala.html">Tour of Scala</a> and <a href="https://www.creativescala.org/">Creative Scala</a>.</p>

<h3 id="variables-functions-and-types">Variables, functions and types</h3>

<p>The basic expressions in a functional programming language such as Scala are
variables, functions and types. Variables, like their mathematical counterpart,
are containers that can store a value.<label for="id-sn-value" class="margin-toggle sidenote-number"></label><input type="checkbox" id="id-sn-value" class="margin-toggle" /><span class="sidenote">Variable is not completely accurate terminology here. <code class="language-plaintext highlighter-rouge">val</code> stores a value which is (in functional programming terminology) immutable, i.e., it cannot change. It is more like a constant, rather than a variable. In this book, we will rarely use mutable <code class="language-plaintext highlighter-rouge">var</code> variables. </span> For example:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">myNumber</span> <span class="k">=</span> <span class="mi">3</span>
</code></pre></div></div>
</div>

<p>Let’s break this example down into its parts. The word <code class="language-plaintext highlighter-rouge">val</code> tells the
computer that you will specify a <em>value</em>, which is a container storing a
constant (in this case the integer 3). The <em>identifier</em> (name) of this value is
the word <code class="language-plaintext highlighter-rouge">myNumber</code>. The <em>assignment operator</em> <code class="language-plaintext highlighter-rouge">=</code> takes the value on its
right side and stores is in the container on the left side.</p>

<p>Any container in Scala has a <em>type</em>. For example, the value <code class="language-plaintext highlighter-rouge">myNumber</code>
above has type <code class="language-plaintext highlighter-rouge">Int</code> which stands for integer. Scala can often derive these
types automatically, but for clarity you may want to use <em>explicit types</em>:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">mySecondNumber</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>
</div>

<p>Types are helpful. They provide a safety net against programming mistakes
since you cannot assign a value that is incompatible with the specified type.
Running the following code results in a <code class="language-plaintext highlighter-rouge">type mismatch</code> error and the
compiler (i.e., the software that interprets and runs your code) will even tell
you which type it expected and which type you provided.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">mySecondNumber</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.9</span>
</code></pre></div></div>
</div>

<p>Functions allow us to write code that takes input, one or more <em>arguments</em>, and
returns output. For example, addition \(add(x, y) = x+y\) can be coded as:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>

<span class="nf">add</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>The word <code class="language-plaintext highlighter-rouge">def</code> specifies that we are constructing a <em>function</em> with the
<em>identifier</em> <code class="language-plaintext highlighter-rouge">add</code>. The comma-separated list between parantheses is the list
of arguments you can pass to this function, where each argument has a specified
type. Functions require that the type of the output is explicitly defined, in
this example <code class="language-plaintext highlighter-rouge">Int</code>. Then the assignment operator <code class="language-plaintext highlighter-rouge">=</code> links the <em>body</em> of
function which is delineated by curly brackets. Whenever we call this function
with the right arguments, the value of the body is computed relative to the
arguments and that value is the output of the function.</p>

<div class="question-top"><div class="question" id="question-1"><div class="question-body"><div class="question-header">Question 9.1</div> <p>Fill in the blanks in the code below and write a function that computes the
following equation: \(f(a, b, c) = a + b * c\)</p>
<div class="answer" id="question-1-heading-1"><a onclick="document.getElementById('question-1-answer-1').style.display = document.getElementById('question-1-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-1-answer-1" style="display: none;"><p>You need to replace the dots <code class="language-plaintext highlighter-rouge">...</code> with a list of comma separated arguments,
and replace the three question marks <code class="language-plaintext highlighter-rouge">???</code> with the expression that evaluates
the equation.</p>
</div></div>
</div></div></div>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">equation</span><span class="o">(...)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="o">???</span>
<span class="o">}</span>

<span class="nf">equation</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span>    <span class="c1">// Test the function, true if correct.</span>
</code></pre></div></div>
</div>

<p>Functions in Scala have types too which becomes clearer with the following
alternative notation.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
<span class="nf">add</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>This notation is not used often since it is hard to read, but it explicitly
defines the function’s type which is very similar to how we express function
types mathematically:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Scala</th>
      <th style="text-align: center"><code class="language-plaintext highlighter-rouge">(Int, Int) =&gt; Int</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Math</td>
      <td style="text-align: center">\(add: \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{N}\)</td>
    </tr>
  </tbody>
</table>

<p>In functional programming languages like Scala you can even pass a function as
an argument of another function. This is a powerful way to organize your code
and very useful in writing simulation code that is closely tied to formal
theories. In a sense, a theory is a function itself, mapping a list of arguments
(input) to output. We’ve seen that some formal theories can have functions as
arguments. For example, <span style="font-variant: small-caps;">Selecting invitees (version 1) </span> in <a href="/lovelace/part_ii/subset">Chapter
4</a> takes as input the function \(like: P \times P
\rightarrow \{true, false\}\). Here is a (partial) example of a function as
argument.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selectingInvitees</span><span class="o">(...,</span> <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span>
</code></pre></div></div>

<p>We return to selecting invitees in the <a href="/lovelace/part_iii/sim_subset_choice">next
chapter</a>, where we will use this coding
strategy. For now, we should note one syntactic oddity in the Scala language.
Sometimes when you pass a function as an argument, the compiler will complain
with the following message:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: missing argument list for method myFun
Unapplied methods are only converted to functions when a function type is expected.
You can make this conversion explicit by writing `myFun _` or `myFun(_)` instead of `myFun`.
</code></pre></div></div>
<p>The solution for this problem is often following the instructions in the error
 explicitly and add an underscore <code class="language-plaintext highlighter-rouge">_</code> to the function. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">selectingInvitees</span><span class="o">(...,</span> <span class="n">like</span><span class="o">)</span>    <span class="c1">// Procudes error.</span>
<span class="nf">selectingInvitees</span><span class="o">(...,</span> <span class="n">like</span> <span class="k">_</span><span class="o">)</span>  <span class="c1">// Correct.</span>
</code></pre></div></div>

<p>Finally, while we won’t go into details of object-orientation here, it is useful
to know that some functions accompany certain types. For example, the type
<code class="language-plaintext highlighter-rouge">String</code> has functions built-in that can be called with the dot-notation.
These functions (also called <em>methods</em>) have access to the value they are called
upon. The following example called method <code class="language-plaintext highlighter-rouge">toUpperCase</code> that evaluates to
the upper-case version of the original string.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"This is a String."</span><span class="o">.</span><span class="py">toUpperCase</span>
</code></pre></div></div>
</div>

<p><label for="mn-auto-complete" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-auto-complete" class="margin-toggle" /><span class="marginnote">Auto-complete can be triggered with
<code class="language-plaintext highlighter-rouge">Ctrl-space</code> or <code class="language-plaintext highlighter-rouge">Cmd-space</code> in Scalafiddle which we use in this book.
Other development tools often use the same key-command, or alternatively the
<code class="language-plaintext highlighter-rouge">Tab</code> key. </span> Many Scala development tools allow you to look through the
list of methods by using <em>auto completion</em>. Just add a <code class="language-plaintext highlighter-rouge">.</code> to a value and
access auto complete to open the list.</p>

<h3 id="blocks-and-scope">Blocks and scope</h3>

<p>We have implicitly used the notions of <em>block</em> and <em>scope</em>, but how are they
defined? In Scala a block is a sequence of expressions *delineated by curly
brackets. A block has a value which is the value of the *last statement in the
block.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
  <span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="mi">3</span>
  <span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="mi">6</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>       <span class="c1">// This block evaluates to 9 with type Int.</span>
<span class="o">}</span>
</code></pre></div></div>
</div>

<p>Blocks can be nested, but values and functions defined within a block cannot
be accessed outside that block. This property is known as scope, accessing
values or functions out of scope results in a compiler error:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
  <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">3</span>

  <span class="o">{</span>
    <span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="mi">6</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>       <span class="c1">// Valid, x and y are in this block's scope.</span>
  <span class="o">}</span>

  <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>         <span class="c1">// Invalid, y is outside this block's scope.</span>
<span class="o">}</span>
</code></pre></div></div>
</div>

<h3 id="conditional">Conditional</h3>

<p>The <em>conditional</em> expression is more colloquially known as the if-then-else
expression. It allows for branching paths of code, depending on the truth
value of the conditional. An example (try changing the value of <code class="language-plaintext highlighter-rouge">x</code>):</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">4</span>
<span class="nf">if</span><span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"X is even."</span><span class="o">)</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"X is odd."</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>
</div>

<p>Each part of the conditional consists of a code block, though for single
expressions the curly brackets to simplify the code:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">4</span>
<span class="nf">if</span><span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"X is even."</span><span class="o">)</span>
<span class="k">else</span> <span class="nf">println</span><span class="o">(</span><span class="s">"X is odd."</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>You can have an arbitrary number of branching paths using <code class="language-plaintext highlighter-rouge">else if</code>:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">4</span>
<span class="nf">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"X is negative."</span><span class="o">)</span>
<span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"X is zero."</span><span class="o">)</span>
<span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"X is small."</span><span class="o">)</span>
<span class="k">else</span> <span class="nf">println</span><span class="o">(</span><span class="s">"X is large."</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>The conditional expression is a block with nested blocks. This means that it
evaluates to the value of the last expression in the block that is evaluated
by the conditional. This behaviour is useful when defining a function whose
output is computed differently depending on some truth condition. For example,
a function that computes the absolute value of <code class="language-plaintext highlighter-rouge">x</code> multiplies <code class="language-plaintext highlighter-rouge">x</code> with
-1 if <code class="language-plaintext highlighter-rouge">x</code> is negative and otherwise evaluates to <code class="language-plaintext highlighter-rouge">x</code>.</p>

<div class="question-top"><div class="question" id="question-2"><div class="question-body"><div class="question-header">Question 9.2</div> <p>Complete the code below by implementing the body of <code>abs(x: Int): Int
</code>. The function should evaluate to the absolute (positive) value of
<code>x</code>.</p>
<div class="answer" id="question-.2-heading-1"><a onclick="document.getElementById('question-.2-answer-1').style.display = document.getElementById('question-.2-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.2-answer-1" style="display: none;"><p>You need to use the conditional expression. Look at the examples above where the
conditional tests for negative numbers. You need to distinguish two cases:
<code>x</code> is negative or not and for each case compute the right value.</p>
</div></div>
</div></div></div>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="o">???</span>
<span class="o">}</span>

<span class="nf">abs</span><span class="o">(-</span><span class="mi">10</span><span class="o">)</span> <span class="o">==</span> <span class="mi">10</span>    <span class="c1">// Test the function, true if correct.</span>
</code></pre></div></div>
</div>

<h3 id="basic-types">Basic types</h3>

<p>Scala comes with a plethora of types and datastructures, many of which fall
beyond the scope of this book. However, the following basic types and their
operators will be very useful to know.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Type</th>
      <th style="text-align: left">Math equivalent</th>
      <th style="text-align: left">Example value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Int</code></td>
      <td style="text-align: left">\(\mathbb{N}\)</td>
      <td style="text-align: left">3</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Double</code></td>
      <td style="text-align: left">\(\mathbb{R}\)</td>
      <td style="text-align: left">2.7</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Boolean</code></td>
      <td style="text-align: left">\(\{true, false\}\)</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Char</code></td>
      <td style="text-align: left">n.a.</td>
      <td style="text-align: left">‘c’</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">String</code></td>
      <td style="text-align: left">n.a.</td>
      <td style="text-align: left">“Awesome”</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">Double</code> share many operators such as addition <code class="language-plaintext highlighter-rouge">+</code>,
subtraction <code class="language-plaintext highlighter-rouge">-</code>, multiplication <code class="language-plaintext highlighter-rouge">*</code> and division <code class="language-plaintext highlighter-rouge">/</code>. The library
<code class="language-plaintext highlighter-rouge">Math</code> also contains several useful functions which you can apply with the
dot notation:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">val</span> <span class="nv">y</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">6</span>

<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">y</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>            <span class="c1">// Division.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">y</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span>            <span class="c1">// Remainder or modulo.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">Math</span><span class="o">.</span><span class="py">pow</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>   <span class="c1">// Exponentiation, x^y.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">Math</span><span class="o">.</span><span class="py">min</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">Math</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>
</div>

<p>For Boolean types these are some common expressions:</p>
<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">println</span><span class="o">(</span><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="o">)</span>   <span class="c1">// Logical and.</span>
<span class="nf">println</span><span class="o">(</span><span class="kc">true</span> <span class="o">||</span> <span class="kc">false</span><span class="o">)</span>  <span class="c1">// Logical or.</span>
<span class="nf">println</span><span class="o">(</span><span class="kc">true</span> <span class="o">^</span> <span class="kc">true</span><span class="o">)</span>    <span class="c1">// Logical xor.</span>
<span class="nf">println</span><span class="o">(!</span><span class="kc">true</span><span class="o">)</span>          <span class="c1">// Negation.</span>
</code></pre></div></div>
</div>

<p>And these can be combined with numbers like so:</p>
<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">val</span> <span class="nv">y</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">6</span>

<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>          <span class="c1">// Number between 1 and 3 (inclusive).</span>
<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>      <span class="c1">// Positive even number.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="c1">// Either x or y is even, not both.</span>
<span class="nf">println</span><span class="o">(!(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">))</span>                 <span class="c1">// x is positive.</span>
</code></pre></div></div>
</div>

<p>If you change in the code example above <code class="language-plaintext highlighter-rouge">Double</code> to <code class="language-plaintext highlighter-rouge">Int</code> you might
notice that there is a certain compatility between the two types. That is, the
compiler does not give a type error when you add a double to an integer, even
though the addition function expects two doubles or two integers. <label for="mn-id-polymorphism" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-id-polymorphism" class="margin-toggle" /><span class="marginnote">This property is known as <em>polymorphism</em> and is an
advanced topic. For the curious, see this <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">overview on
Wikipedia</a>. </span> This is because Scala knows it can convert an integer to a double value, which
it will automatically do.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">val</span> <span class="nv">y</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="n">x</span><span class="o">+</span><span class="n">y</span>    <span class="c1">// Evaluates to a Double value 5.5</span>
</code></pre></div></div>
</div>

<p>Some types cannot be converted and when you try to mix these, the compiler will
let you know with an error:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">x</span> <span class="o">+</span> <span class="n">b</span>    <span class="c1">// How to add a Boolean to an Int?</span>
</code></pre></div></div>
</div>

<p>This conversion also kicks in when calling a function with compatible arguments:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span><span class="n">b</span>
<span class="nf">add</span><span class="o">(</span><span class="mf">1.4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>
</div>

<div class="question-top"><div class="question" id="question-3"><div class="question-body"><div class="question-header">Question 9.3</div> <p>This conversion often only works one way. It is not possible to convert a Double
to an Int without loosing information. Observe what happens when you run the
code example above after changing the type of the arguments of <code>add</code> to
<code>Int</code>.</p>
</div></div></div>

<h3 id="lists-sets-and-tuples">Lists, sets and tuples</h3>

<p>When you want to store multiple values you can use collections. Example
collections could be the temperature forecast for the next seven days:</p>

<table>
  <tbody>
    <tr>
      <td>22.2 °C</td>
    </tr>
    <tr>
      <td>23.1 °C</td>
    </tr>
    <tr>
      <td>23.7 °C</td>
    </tr>
    <tr>
      <td>22.3 °C</td>
    </tr>
    <tr>
      <td>24.3 °C</td>
    </tr>
    <tr>
      <td>24.7 °C</td>
    </tr>
    <tr>
      <td>25.1 °C</td>
    </tr>
  </tbody>
</table>

<p>Or the people that you know: Erik, Lamar, Angelica, Emanuel, Lorraine, Meghan,
Myron, Erica, Lester, Javier, Kelly, Abraham, Lindsay, Harriet, and Guadalupe.
Or the cost of a menu card item: Vegan pie costs €9,90.</p>

<p>Some collections, like the temperature forecast and menu card item, are ordered:
one value follows the next. In math, these are expressed in a list or sequence
\(\langle 22.2, 23.1, 23.7, 22.3, 24.3, 24.7, 25.1 \rangle\) or a tuple
\((\text{vegan pie}, 9.9)\). Unordered collections, such as people, are
expressed in a set \(\{\text{Erik},\) \(\text{Lamar},\) \(\text{Angelica},\)
\(\text{Emanuel},\) \(\text{Lorraine},\) \(\text{Meghan},\) \(\text{Myron},\)
\(\text{Erica},\) \(\text{Lester},\) \(\text{Javier},\) \(\text{Kelly},\)
\(\text{Abraham},\) \(\text{Lindsay},\) \(\text{Harriet},\)
\(\text{Guadalupe}\}\).</p>

<p>In Scala we can store ordered collections in a <code class="language-plaintext highlighter-rouge">List</code> or tuple and unordered
collections in a <code class="language-plaintext highlighter-rouge">Set</code>:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">forecast</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">22.2</span><span class="o">,</span> <span class="mf">23.1</span><span class="o">,</span> <span class="mf">23.7</span><span class="o">,</span> <span class="mf">22.3</span><span class="o">,</span> <span class="mf">24.3</span><span class="o">,</span> <span class="mf">24.7</span><span class="o">,</span> <span class="mf">25.1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">menuItem</span> <span class="k">=</span> <span class="o">(</span><span class="s">"Vegan pie"</span><span class="o">,</span> <span class="mf">9.90</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">people</span>   <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"Erik"</span><span class="o">,</span> <span class="s">"Lamar"</span><span class="o">,</span> <span class="s">"Angelica"</span><span class="o">,</span> <span class="s">"Emanuel"</span><span class="o">,</span> <span class="s">"Lorraine"</span><span class="o">,</span>
                   <span class="s">"Meghan"</span><span class="o">,</span> <span class="s">"Myron"</span><span class="o">,</span> <span class="s">"Erica"</span><span class="o">,</span> <span class="s">"Lester"</span><span class="o">,</span> <span class="s">"Javier"</span><span class="o">,</span> <span class="s">"Kelly"</span><span class="o">,</span>
                   <span class="s">"Abraham"</span><span class="o">,</span> <span class="s">"Lindsay"</span><span class="o">,</span> <span class="s">"Harriet"</span><span class="o">,</span> <span class="s">"Guadalupe"</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>We’ll dive into sets below using the <code class="language-plaintext highlighter-rouge">mathlib</code> library, so let’s first get
some familiarity with lists. Some basic examples are in the code block below.
Try playing around with them to see what they do.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">forecastThisWeek</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">22.2</span><span class="o">,</span> <span class="mf">23.1</span><span class="o">,</span> <span class="mf">23.7</span><span class="o">,</span> <span class="mf">22.3</span><span class="o">,</span> <span class="mf">24.3</span><span class="o">,</span> <span class="mf">24.7</span><span class="o">,</span> <span class="mf">25.1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">forecastNextWeek</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">22.3</span><span class="o">,</span> <span class="mf">19.8</span><span class="o">,</span> <span class="mf">18.4</span><span class="o">,</span> <span class="mf">18.0</span><span class="o">,</span> <span class="mf">17.6</span><span class="o">,</span> <span class="mf">17.5</span><span class="o">,</span> <span class="mf">17.2</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="mf">23.1</span> <span class="o">::</span> <span class="n">forecastThisWeek</span><span class="o">)</span>               <span class="c1">// Prepend element.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">forecastThisWeek</span> <span class="o">:::</span> <span class="n">forecastNextWeek</span><span class="o">)</span>  <span class="c1">// Prepend list.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">size</span><span class="o">)</span>                  <span class="c1">// Number of elements in list.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="mf">23.7</span><span class="o">))</span>        <span class="c1">// Does the list contain element?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">head</span><span class="o">)</span>                  <span class="c1">// The first element of the list.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">tail</span><span class="o">)</span>                  <span class="c1">// Everything except the first element.</span>
<span class="nf">println</span><span class="o">(</span><span class="nf">forecastThisWeek</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>                    <span class="c1">// The n-th element.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span>               <span class="c1">// Checks whether the list is emtpy.</span>
</code></pre></div></div>
</div>

<p>The power of collections lies in being able to apply to all of the elements. The
idea is that if we have a function that applies to one element, e.g., \(sq(x) =
x^2)\), we can apply it to all elements in the list. The most common of these
applications is called <code class="language-plaintext highlighter-rouge">map</code>. It takes as argument a function <code class="language-plaintext highlighter-rouge">f</code> and
evaluates to a list where each element computed using <code class="language-plaintext highlighter-rouge">f</code>:</p>

<table>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">list</code></td>
      <td><code class="language-plaintext highlighter-rouge">1</code></td>
      <td><code class="language-plaintext highlighter-rouge">2</code></td>
      <td><code class="language-plaintext highlighter-rouge">3</code></td>
      <td><code class="language-plaintext highlighter-rouge">4</code></td>
    </tr>
    <tr>
      <td> </td>
      <td>\(\downarrow\)</td>
      <td>\(\downarrow\)</td>
      <td>\(\downarrow\)</td>
      <td>\(\downarrow\)</td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">sq(1)</code></td>
      <td><code class="language-plaintext highlighter-rouge">sq(2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">sq(3)</code></td>
      <td><code class="language-plaintext highlighter-rouge">sq(4)</code></td>
    </tr>
    <tr>
      <td> </td>
      <td>\(\downarrow\)</td>
      <td>\(\downarrow\)</td>
      <td>\(\downarrow\)</td>
      <td>\(\downarrow\)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">list.map(sq)</code></td>
      <td><code class="language-plaintext highlighter-rouge">1</code></td>
      <td><code class="language-plaintext highlighter-rouge">4</code></td>
      <td><code class="language-plaintext highlighter-rouge">9</code></td>
      <td><code class="language-plaintext highlighter-rouge">16</code></td>
    </tr>
  </tbody>
</table>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Function that computes the square root of x.</span>
<span class="k">def</span> <span class="nf">sq</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">sq</span><span class="o">))</span>
</code></pre></div></div>
</div>

<p>The type of the argument of the function must be the same type as the elements
in the list, but its output can be of any type. For example, take an <code class="language-plaintext highlighter-rouge">Int</code>
and return a <code class="language-plaintext highlighter-rouge">String</code>.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Function that creates a String with x "x"s.</span>
<span class="k">def</span> <span class="nf">xx</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nf">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="s">"x"</span>
  <span class="k">else</span> <span class="s">"x"</span> <span class="o">+</span> <span class="nf">xx</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">xx</span><span class="o">))</span>
</code></pre></div></div>
</div>

<p>What other useful things can we do with lists? Below are some self-explanatory
examples.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Function that checks whether x is even.</span>
<span class="k">def</span> <span class="nf">isEven</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="o">}</span>
<span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">exists</span><span class="o">(</span><span class="n">isEven</span><span class="o">))</span>    <span class="c1">// Does list contain an element that isEven?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">exists</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">))</span>     <span class="c1">// Implicit function, does the list contain an element larger than 3?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">forall</span><span class="o">(</span><span class="n">isEven</span><span class="o">))</span>    <span class="c1">// Do all elements in list return true for isEven?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">forall</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">))</span>  <span class="c1">// Implicit function, does the list contain an element larger than 3?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isEven</span><span class="o">))</span>    <span class="c1">// Filter out all elements that return true for isEven.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">))</span>     <span class="c1">// Filter out all elements less than 3.</span>
</code></pre></div></div>
</div>

<p>There are some special methods for lists that contain numbers:</p>
<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Function that checks whether x is even.</span>
<span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">sum</span><span class="o">)</span>             <span class="c1">// The sum of all numbers in list.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">product</span><span class="o">)</span>         <span class="c1">// The product of all numbers in list.</span>
</code></pre></div></div>
</div>

<p>Many of the functions and methods that work for lists, also work for other
collections such as sets. Even a <code>String</code> can be treated as a
collection as it is essentially a list of characters.</p>

<div class="question-top"><div class="question" id="question-4"><div class="question-body"><div class="question-header">Question 9.4</div> <p>Look at the code scaffold below. Implement the body of the function
<code>consonant</code> and choose the method to apply to <code>sentence</code>
such that the code evaluates to the sentence with only consonants.</p>
<div class="answer" id="question-.4-heading-1"><a onclick="document.getElementById('question-.4-answer-1').style.display = document.getElementById('question-.4-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.4-answer-1" style="display: none;"><p>The list of (English) vowels is given. Write code that checks if the
<code>character</code> does not exist within vowels.</p>
</div></div>
</div></div></div>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">sentence</span> <span class="k">=</span> <span class="s">"Hi, you're doing awesome!"</span>
<span class="k">val</span> <span class="nv">vowels</span>   <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'e'</span><span class="o">,</span> <span class="sc">'i'</span><span class="o">,</span> <span class="sc">'o'</span><span class="o">,</span> <span class="sc">'u'</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">consonant</span><span class="o">(</span><span class="n">character</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="o">???</span>
<span class="o">}</span>

<span class="nv">sentence</span><span class="o">.</span><span class="py">___</span><span class="o">(</span><span class="n">consonant</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h3 id="generics">Generics</h3>

<p>Collections in Scala are what is called <em>generic</em>. The change their type
depending on the values you apply to them. The list containing the forecast
consists of values of type <code class="language-plaintext highlighter-rouge">Int</code>, therefore the type of <code class="language-plaintext highlighter-rouge">forecast</code> is
<code class="language-plaintext highlighter-rouge">List[Int]</code>. In Scala, the type of a generic includes the type of its
contents denoted between square brackets.</p>

<div class="question-top"><div class="question" id="question-5"><div class="question-body"><div class="question-header">Question 9.5</div> <p>What is the type of <code>vowels</code>? Fill in the blanks: <code>List[___]</code></p>
<div class="answer" id="question-.5-heading-1"><a onclick="document.getElementById('question-.5-answer-1').style.display = document.getElementById('question-.5-answer-1').style.display === 'none' ? '' : 'none';">Hint?</a><div id="question-.5-answer-1" style="display: none;"><p>What is the type of the values contained in the list?</p>
</div></div>
</div></div></div>

<div class="stopandthink"><div class="st-header">Stop and think</div>
<p>What benefits do we get from generics?</p>
</div>

<p>Collections, courtesy of being generic, can store different types. A set of
doubles? No problem <code class="language-plaintext highlighter-rouge">Set[Double]</code>. A list of Booleans? Easy
<code class="language-plaintext highlighter-rouge">Set[Boolean]</code>! The type of a collection also grants a level of protection
to the programmer. You cannot prepend a Boolean to a list of integers:</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">forecast</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>  <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">22.2</span><span class="o">,</span> <span class="mf">23.1</span><span class="o">,</span> <span class="mf">23.7</span><span class="o">,</span> <span class="mf">22.3</span><span class="o">,</span> <span class="mf">24.3</span><span class="o">,</span> <span class="mf">24.7</span><span class="o">,</span> <span class="mf">25.1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">forecast2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="kc">true</span> <span class="o">::</span> <span class="n">forecast</span>
</code></pre></div></div>
</div>

<p>If you could mix different (incompatible) types in a collection, performing
calculations on that collection would be either undefined (e.g., what does
mean to compute the sum of a list of <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Boolean</code> and <code class="language-plaintext highlighter-rouge">String</code>?)
or it would have unpredictable effects.</p>

<h2 id="mathlib"><code class="language-plaintext highlighter-rouge">mathlib</code></h2>

<p><code class="language-plaintext highlighter-rouge">mathlib</code> is a library written to support the development of simulations of
formal theories (computational-level models specifically). <label for="mn-id-implementation" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-id-implementation" class="margin-toggle" /><span class="marginnote">Admittedly, an exact implementation is not always
possible. Especially when the simulation deviates from the formal theory, it is
important to be able for experts to understand how the simulation is different. </span> Ideally, we want (experts) to be able to read simulation code and
<em>understand</em> that it is an exact implementation of the formal theory. As you may
have noticed during the Scala introduction, functional programming is closely
related to the mathematical language of formal theories. Consider the following
example (toy) formal theory:</p>

<p><label for="mf-id-whatever" class="margin-toggle">⊕</label><input type="checkbox" id="mf-id-whatever" class="margin-toggle" /><span class="marginnote"><img class="fullwidth" src="/lovelace/assets/img/pexels-roman-odintsov-6147834.jpg" /><br /></span>
<span class="problemtitle">Pizza Toppings</span><br /><span class="probleminout">Input:</span> A set of toppings \(T\), a budget \(b\in\mathbb{N}\), and a cost function
for toppings \(c: T\rightarrow \mathbb{N}\)<br /><span class="probleminout">Output:</span> 
A selection of toppings \(T'\subseteq T\) such that \(\sum_{t \in T}c(t) \leq b\).</p>

<p>In this section you will learn how to read (and write) simulation code that
implements a formal theory and is easy to understand that it does what we say it
does. Take a look at the following code implementing <span style="font-variant: small-caps;">Pizza Toppings
</span>. (We assume toppings are represented by <code class="language-plaintext highlighter-rouge">Strings</code>.)</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pizzaToppings</span><span class="o">(</span><span class="n">toppings</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">budget</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">cost</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Helper function to compute the cost of a subset of toppings.</span>
  <span class="k">def</span> <span class="nf">subsetCost</span><span class="o">(</span><span class="n">subset</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nv">subset</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">cost</span><span class="o">)</span> <span class="c1">// Transform each element in subset to its cost using the cost function.</span>
          <span class="o">.</span><span class="py">sum</span>       <span class="c1">// Sum all costs.</span>
  <span class="o">}</span>

  <span class="c1">// Helper function to check if a given subset fits within the budget.</span>
  <span class="k">def</span> <span class="nf">subsetWithinBudget</span><span class="o">(</span><span class="n">subset</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">subsetCost</span><span class="o">(</span><span class="n">subset</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">budget</span>
  <span class="o">}</span>

  <span class="nf">powerset</span><span class="o">(</span><span class="n">toppings</span><span class="o">)</span>            <span class="c1">// The set of all possible subsets.</span>
    <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">subsetWithinBudget</span><span class="o">)</span> <span class="c1">// Filter (keep) all subsets that fit the budget.</span>
    <span class="o">.</span><span class="py">random</span>                     <span class="c1">// Get a random subset.</span>
    <span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>       <span class="c1">// If to random subset exists, return the emtpy set.</span>
<span class="o">}</span>
</code></pre></div></div>
</div>

<p>This code example combines several expressions we covered earlier, but by
breaking down the components it is relatively easy to show that the code
implements <span style="font-variant: small-caps;">Pizza Toppings </span>. Of course, even though math is much
less ambiguous as verbal theory, that does not exclude there being multiple
(equivalent) expressions in math. Some might be easier to translate to Scala
code than others. We will encounter examples where rewriting the mathematical
expressions of the formal theory can help in clarifying the relationship with
the simulation.</p>

<p>In the next section, we explore how <code class="language-plaintext highlighter-rouge">mathlib</code> allows writing code for formal
theories using set theory. The library also contains support for probability and
graph theory. You can find out more at the library <a href="https://github.com/markblokpoel/mathlib">Github
page</a>, but using these advanced
mathematics requires installing a local development environment such as
Jupyter/Almond or Intellij (see <a href="/lovelace/part_iii/simulating#installing-scala-and-mathlib">Installing Scala and <code class="language-plaintext highlighter-rouge">mathlib</code></a>).</p>

<h3 id="set-theory">Set theory</h3>

<p>In this book, set theory plays an important role in formalizing verbal theories,
so we start exploring <code class="language-plaintext highlighter-rouge">mathlib</code> there. This section follows the same
structure as <a href="/lovelace/part_i/math">Chapter 3 - Math concepts and notation</a>.</p>

<p>Creating a set is similar to creating other collections such as lists. Set
membership in Scala is an expression that evaluates to <code class="language-plaintext highlighter-rouge">true</code> if the element
is within the set or <code class="language-plaintext highlighter-rouge">false</code> if it is not. The Scala code below creates the
set \(P = \{\text{Ramiro},\text{Brenda},\text{Molly}\}\), then tests if
\(\text{Ramiro}\in P\) and if \(\text{Saki}\in P\).</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">p</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"Ramiro"</span><span class="o">,</span> <span class="s">"Brenda"</span><span class="o">,</span> <span class="s">"Molly"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="s">"Ramiro"</span> <span class="n">in</span> <span class="n">p</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Saki"</span> <span class="n">in</span> <span class="n">p</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>Subset and superset expressions also evaluate to <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">animals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"cuttlefish"</span><span class="o">,</span> <span class="s">"turtle"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">mammals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">thingsOnEarth</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"cuttlefish"</span><span class="o">,</span> <span class="s">"turtle"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">,</span> <span class="s">"university"</span><span class="o">,</span> <span class="s">"chair"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="n">mammals</span> <span class="o">&lt;</span> <span class="n">animals</span><span class="o">)</span>        <span class="c1">// Mammals is a subset of animals.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">thingsOnEarth</span> <span class="o">&gt;</span> <span class="n">animals</span><span class="o">)</span>  <span class="c1">// Things on Earth is a superset of animals.</span>
</code></pre></div></div>
</div>

<p>Intersection, union and difference evaluate to the correct super- or
subset.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">yourFriends</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"Roberto"</span><span class="o">,</span> <span class="s">"Holly"</span><span class="o">,</span> <span class="s">"Doris"</span><span class="o">,</span> <span class="s">"Charlene"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">myFriends</span> <span class="k">=</span>  <span class="nc">Set</span><span class="o">(</span><span class="s">"Vicky"</span><span class="o">,</span> <span class="s">"Charlene"</span><span class="o">,</span> <span class="s">"Ramiro"</span><span class="o">,</span> <span class="s">"Johnnie"</span><span class="o">,</span> <span class="s">"Roberto"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="n">yourFriends</span> <span class="o">/\</span> <span class="n">myFriends</span><span class="o">)</span> <span class="c1">// Common friends using intersection.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">yourFriends</span> <span class="o">\/</span> <span class="n">myFriends</span><span class="o">)</span> <span class="c1">// Friends we know together using union.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">myFriends</span> <span class="o">\</span> <span class="n">yourFriends</span><span class="o">)</span>  <span class="c1">// Who I know that you don't, using difference.</span>
</code></pre></div></div>
</div>

<p>Before we look at set builder notation, consider the following. In formal
theories, we often use set theoretic notation not as Boolean tests, but to
stipulate the output. E.g., in <span style="font-variant: small-caps;">Pizza Toppings </span>, the output is a
subset \(T'\subseteq T\) that fits in budget. This notation, however, does not
translate directly into Scala code. Consider the following rewrite of the formal
theory output:</p>

<p>\(T' \in \mathcal{P}(T)\) such that \(\sum_{t\in T'}c(t)\leq b\)</p>

<p>This notation still does not easily translate, for two reasons. Firstly, because
the relationship between \(T'\) and the desired property (fits in budget) is
expressed in natural language. Secondly, because there are multiple outputs
possible. Since the theory does not explicitly state which from the possible
outputs is preferred, we need to assume it either returns the entire set or
selects at random.</p>

<p>We can address the first issues by expressing the set of possible outputs and
the relationship between \(T'\) and budget-fit explicitly in math using set
building notation. <label for="mn-id-helperfunctions" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-id-helperfunctions" class="margin-toggle" /><span class="marginnote">The practice of
decomposing parts of a theory (or code) into sub-parts is well known in
mathematics and programming. It can help make math and code more readable,
because we can abstract from the inner workings of a function. </span> We make our
lives easier by defining a help function for cost of subsets: \(cost:
\mathcal{P}(T) \rightarrow \mathbb{N}\), where \(cost(T')=\sum_{t\in T'}c(t)\).
Then the set of all subsets within budget can be defined as:</p>

\[\left\{T'~\middle|~\mathcal{P}(T) \wedge cost(T')\leq b\right\}\]

<p>Here, \(\mathcal{P}\) is the powerset notation. It denotes the set consisting of
all possible subsets and \(T'\) is an element in that set. The set-builder
notation describes the set of all possible subsets that satisfy the budget
constraint. Dealing second issue (multiple possible outputs), we make the
decision to return a random valid output.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pizzaToppings</span><span class="o">(</span><span class="n">toppings</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">budget</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">cost</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</code></pre></div></div>

<p>The helper function that computes the cost of a subset is implemented as:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Helper function to compute the cost of a subset of toppings.</span>
  <span class="k">def</span> <span class="nf">subsetCost</span><span class="o">(</span><span class="n">subset</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">sum</span><span class="o">(</span><span class="n">subset</span><span class="o">,</span> <span class="n">cost</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>We add one more helper function to check if a subset fits within the budget.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Helper function to check if a given subset fits within the budget.</span>
  <span class="k">def</span> <span class="nf">subsetWithinBudget</span><span class="o">(</span><span class="n">subset</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">subsetCost</span><span class="o">(</span><span class="n">subset</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">budget</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Finally, we can define the output of 	 <span style="font-variant: small-caps">Pizza Toppings</span> using set builder notation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">{</span> <span class="nf">powerset</span><span class="o">(</span><span class="n">toppings</span><span class="o">)</span> <span class="o">|</span> <span class="n">subsetWithinBudget</span> <span class="k">_</span> <span class="o">}.</span><span class="py">random</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>
</div>

<p><label for="mn-id-multicode" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-id-multicode" class="margin-toggle" /><span class="marginnote">You may have noticed this code is different
from the example given at the start of this section. Similarly to multiple
mathematical expressions being equivalent, there exist (many) different ways of
implementing the same function. </span> This is a example implementation uses set
builder to construct a set of subsets that fit within budget. Set builder, in
essence, filters out all elements (in the case above the elements are sets) from
the given set that do not satisfy the evaluation function on the right side.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span> <span class="n">givenSet</span> <span class="o">|</span> <span class="n">evalFun</span> <span class="k">_</span> <span class="o">}</span>
</code></pre></div></div>

<div class="question-top"><div class="question" id="question-6"><div class="question-body"><div class="question-header">Question 9.6</div> <p>Complete the code scaffold below such that the set builder expression evaluates
to the subset of odd numbers in <code>numbers</code>.</p>
</div></div></div>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Function that checks if a number is odd.</span>
<span class="k">def</span> <span class="nf">isOdd</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="o">???</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">numbers</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">11</span><span class="o">).</span><span class="py">toSet</span>   <span class="c1">// Set consisting of numbers 0 to 11</span>

<span class="o">{</span> <span class="nc">___</span> <span class="o">|</span> <span class="nc">___</span> <span class="o">}</span>
</code></pre></div></div>
</div>

<p>The final expression for working with sets is the cardinal product \(\times\). The
cardinal product between two sets \(A\) and \(B\) returns a set with all
possible pairs of elements in \(A\) and \(B\). Pairs, in Scala, are represented
as tuples.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">pair</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="s">"Book"</span><span class="o">)</span>
</code></pre></div></div>

<p>The type of a tuple combines the types of the elements. The cardinal product
between two sets yields a set with the subtype of the tuple.</p>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">numbers</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>  <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">items</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"Book"</span><span class="o">,</span> <span class="s">"Candle"</span><span class="o">,</span> <span class="s">"Wine"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">itemNumberPairs</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="n">items</span> <span class="n">x</span> <span class="n">numbers</span>

<span class="nf">println</span><span class="o">(</span><span class="n">itemNumberPairs</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h2 id="simulation-architecture">Simulation architecture</h2>

<p>Now that we’ve covered the basics for Scala and <code class="language-plaintext highlighter-rouge">mathlib</code> we can go cover
what constitutes a computer simulation of a formal theory. To run a computer
simulation you minimally need two components: The implementation of the formal
theory and sample input <a class="citation" href="#guest_how_2020">(Guest &amp; Martin, 2020)</a>. The advantage of simulations
are that you can let the computer do the hard work computing many input-output
mappings, but it is still a lot of work if have to supply each input manually.</p>

<figure><img src="/lovelace/assets/img/simulation-components.svg" /><figcaption class="maincolumn-figure">A simulation architecture
consists of the implementation of the formal theory and an input generator that
supplies inputs.</figcaption></figure>

<p>Manually supplying input can still be useful for checking for errors in the
code, or to investigate particular limit cases of the theory and initial
explorations. We will use manual inputs throughout the next chapters.</p>

<p>However, a more complete simulation covers many inputs, preferably exploring a
wide range of different cases. For example, with the <span style="font-variant: small-caps;">Pizza Toppings </span>
example one might want to explore inputs ranging from few to many toppings, with
many different cost functions and budget. In these cases it is useful to write
a helper function that can generate input with various properties.</p>

<p>Unfortunately, like with formalizing verbal theory, there is not a single recipe
for writing input generators. Generators are highly contingent on the theory and
the parts of the input domain you wish to simulate. Within the context of this
book, you don’t need to write your own generators, but over the next chapters
you will use example input generators provided by us.</p>

<p>We can put most generators in one of two categories: unconstrained input
generation or constrained input generation. Understanding the difference
between the to types of generators is important, as it impacts the kinds of
inputs one can generate, which in turn will impact the computer simulation
results.</p>

<p>Any procedure for randomly generating input will likely be biased. That means
that some inputs are more likely to be generated than others. This can be due to
particular structure in the input space, or due to properties of the generator.</p>

<p>A simplified representation of this bias is shown in the figure below. Out of
the set of all possible inputs, the darker areas might be more likely to be
generated than the light. Of course, input bias will also bias the output of the
simulations.</p>

<figure><img src="/lovelace/assets/img/generator-bias.svg" /><figcaption class="maincolumn-figure">Bias in an unconstrained random
generator may not cover all possible inputs.</figcaption></figure>

<p>We can deal with this bias by analyzing how well the generated inputs cover the
parts of the space you are interested in. An <em>unconstrained input generator</em> is
best used as such. These generators have bias over which we have no control such
as in the figure above. Bias doesn’t render the simulations useless, as long as
we can characterize the bias and have some understanding of how it impacts the
results and limits our conclusions.</p>

<p>Alternatively, we can try to implement a <em>constrained input generator</em>. These
types of generators are still biased, but we have some degree of control over
the inputs they generate. Since there is still bias, it is wise to take that
into account, but we may be better able to cover the input space by setting the
right constraints. We can even use multiple sets of constraints to cover more
area of the input space, as is shown in the figure below.</p>

<figure><img src="/lovelace/assets/img/generator-bias-constrained.svg" /><figcaption class="maincolumn-figure">Bias in constrained
input generators. Each &#8220;bubble&#8221; is a particular set of constraints on the same
input generator, moving the bias across all possible inputs. By combining these
biases, we can cover more of the input domain.</figcaption></figure>

<p>So why don’t we always write constrained input generators? This is because
they are hard to make, at least harder than the unconstrained versions. It is a
question we need to ask when developing simulations: Does the bias in the
unconstrained generator skew the results too much? Then consider investing in
developing a constrained input generator. For now, you can lean back and enjoy
the generators we provide.</p>

<h2 id="cheat-sheet">Cheat sheet</h2>

<div data-scalafiddle="" data-template="mathlib" data-theme="light">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**** BASIC TYPES ****/</span>

<span class="k">val</span> <span class="nv">integer</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">val</span> <span class="nv">double</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">2.7</span>
<span class="k">val</span> <span class="nv">bool</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="k">val</span> <span class="nv">character</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="sc">'c'</span>
<span class="k">val</span> <span class="nv">string</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Awesome"</span>

<span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">integer</span>
<span class="k">val</span> <span class="nv">y</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">double</span>

<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">y</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>            <span class="c1">// Division.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">y</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span>            <span class="c1">// Remainder or modulo.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">Math</span><span class="o">.</span><span class="py">pow</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>   <span class="c1">// Exponentiation, x^y.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">Math</span><span class="o">.</span><span class="py">min</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">Math</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>

<span class="nf">println</span><span class="o">(</span><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="o">)</span>   <span class="c1">// Logical and.</span>
<span class="nf">println</span><span class="o">(</span><span class="kc">true</span> <span class="o">||</span> <span class="kc">false</span><span class="o">)</span>  <span class="c1">// Logical or.</span>
<span class="nf">println</span><span class="o">(</span><span class="kc">true</span> <span class="o">^</span> <span class="kc">true</span><span class="o">)</span>    <span class="c1">// Logical xor.</span>
<span class="nf">println</span><span class="o">(!</span><span class="kc">true</span><span class="o">)</span>          <span class="c1">// Negation.</span>

<span class="cm">/**** Lists ****/</span>
<span class="k">val</span> <span class="nv">forecastThisWeek</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">22.2</span><span class="o">,</span> <span class="mf">23.1</span><span class="o">,</span> <span class="mf">23.7</span><span class="o">,</span> <span class="mf">22.3</span><span class="o">,</span> <span class="mf">24.3</span><span class="o">,</span> <span class="mf">24.7</span><span class="o">,</span> <span class="mf">25.1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">forecastNextWeek</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">22.3</span><span class="o">,</span> <span class="mf">19.8</span><span class="o">,</span> <span class="mf">18.4</span><span class="o">,</span> <span class="mf">18.0</span><span class="o">,</span> <span class="mf">17.6</span><span class="o">,</span> <span class="mf">17.5</span><span class="o">,</span> <span class="mf">17.2</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="mf">23.1</span> <span class="o">::</span> <span class="n">forecastThisWeek</span><span class="o">)</span>               <span class="c1">// Prepend element.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">forecastThisWeek</span> <span class="o">:::</span> <span class="n">forecastNextWeek</span><span class="o">)</span>  <span class="c1">// Prepend list.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">size</span><span class="o">)</span>                  <span class="c1">// Number of elements in list.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="mf">23.7</span><span class="o">))</span>        <span class="c1">// Does the list contain element?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">head</span><span class="o">)</span>                  <span class="c1">// The first element of the list.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">tail</span><span class="o">)</span>                  <span class="c1">// Everything except the first element.</span>
<span class="nf">println</span><span class="o">(</span><span class="nf">forecastThisWeek</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>                    <span class="c1">// The n-th element.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">forecastThisWeek</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span>               <span class="c1">// Checks whether the list is emtpy.</span>

<span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">sq</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>   <span class="c1">// Function that computes the square root of x.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">sq</span><span class="o">))</span>         <span class="c1">// Map each value in list to sq(_)</span>

<span class="k">def</span> <span class="nf">isEven</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1">// Function that checks whether x is even.</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">exists</span><span class="o">(</span><span class="n">isEven</span><span class="o">))</span>    <span class="c1">// Does list contain an element that isEven?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">exists</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">))</span>     <span class="c1">// Implicit function, does the list contain an element larger than 3?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">forall</span><span class="o">(</span><span class="n">isEven</span><span class="o">))</span>    <span class="c1">// Do all elements in list return true for isEven?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">forall</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">))</span>  <span class="c1">// Implicit function, does the list contain an element larger than 3?</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isEven</span><span class="o">))</span>    <span class="c1">// Filter out all elements that return true for isEven.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">))</span>     <span class="c1">// Filter out all elements less than 3.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">sum</span><span class="o">)</span>               <span class="c1">// The sum of all numbers in list.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">product</span><span class="o">)</span>           <span class="c1">// The product of all numbers in list.</span>

<span class="cm">/**** Tuples ****/</span>
<span class="k">val</span> <span class="nv">menuItem</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">"Vegan pie"</span><span class="o">,</span> <span class="mf">9.90</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">menuItem</span><span class="o">.</span><span class="py">_1</span><span class="o">)</span>            <span class="c1">// Get the first value of the tuple.</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">menuItem</span><span class="o">.</span><span class="py">_2</span><span class="o">)</span>            <span class="c1">// Get the second value of the tuple.</span>

<span class="cm">/**** Sets ****/</span>
<span class="k">val</span> <span class="nv">animals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"cuttlefish"</span><span class="o">,</span> <span class="s">"turtle"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">mammals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">thingsOnEarth</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"cuttlefish"</span><span class="o">,</span> <span class="s">"turtle"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">,</span> <span class="s">"university"</span><span class="o">,</span> <span class="s">"chair"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="s">"cat"</span> <span class="n">in</span> <span class="n">animals</span><span class="o">)</span>         <span class="c1">// Test if element is in  the set.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">mammals</span> <span class="o">&lt;</span> <span class="n">animals</span><span class="o">)</span>        <span class="c1">// Mammals is a subset of animals.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">thingsOnEarth</span> <span class="o">&gt;</span> <span class="n">animals</span><span class="o">)</span>  <span class="c1">// Things on Earth is a superset of animals.</span>

<span class="k">val</span> <span class="nv">yourFriends</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"Roberto"</span><span class="o">,</span> <span class="s">"Holly"</span><span class="o">,</span> <span class="s">"Doris"</span><span class="o">,</span> <span class="s">"Charlene"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">myFriends</span> <span class="k">=</span>  <span class="nc">Set</span><span class="o">(</span><span class="s">"Vicky"</span><span class="o">,</span> <span class="s">"Charlene"</span><span class="o">,</span> <span class="s">"Ramiro"</span><span class="o">,</span> <span class="s">"Johnnie"</span><span class="o">,</span> <span class="s">"Roberto"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="n">yourFriends</span> <span class="o">/\</span> <span class="n">myFriends</span><span class="o">)</span> <span class="c1">// Common friends using intersection.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">yourFriends</span> <span class="o">\/</span> <span class="n">myFriends</span><span class="o">)</span> <span class="c1">// Friends we know together using union.</span>
<span class="nf">println</span><span class="o">(</span><span class="n">myFriends</span> <span class="o">\</span> <span class="n">yourFriends</span><span class="o">)</span>  <span class="c1">// Who I know that you don't, using difference.</span>

<span class="nf">println</span><span class="o">({</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="o">|</span> <span class="n">isEven</span> <span class="k">_</span> <span class="o">})</span> <span class="c1">// Build a set of even numbers.</span>

<span class="nf">println</span><span class="o">(</span><span class="n">myFriends</span> <span class="n">x</span> <span class="n">animals</span><span class="o">)</span>      <span class="c1">// Set of all pairs of friends and animals using cardinal product.</span>
</code></pre></div></div>
</div>

<h3 id="references">References</h3>

<p>Guest, O., &amp; Martin, A. E. (2021). <a href="https://doi.org/10.1177/1745691620970585">How computational modeling can force theory building in psychological science.</a> <em>Perspectives on Psychological Science 16</em>(4),789-802.</p>

<p>Odersky, M., Spoon, L., &amp; Venners, B. (2019). <em>Programming in Scala, 4th
Edition</em>. Artima.</p>


<div class="nav-wrapper">
	<div class="prev-chapter">
		
		<p><a href="/lovelace/part_iii/simulating">Previous: Simulating in Scala</a></p>
		
	</div>
	<div class="next-chapter">
		
		<p><a href="/lovelace/part_iii/sim_subset_choice">Next: Subset choice</a></p>
		
	</div>
</div>

    </article>
    <span class="print-footer">Scala and mathlib - September 3, 2021 - Mark Blokpoel and Iris van Rooij</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    
      <li>
        <a href="mailto:m.blokpoel@donders.ru.nl">Mark
		<span class="icon-mail3"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.markblokpoel.com">
		<span class="icon-html-five"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.twitter.com/MarkBlokpoel">
		<span class="icon-twitter"></span>
		</a>
      </li>
    
      <li>
        <a href="//github.com/markblokpoel">
		<span class="icon-github"></span>
		</a>
      </li>
    
      <li>
        <a href="mailto:i.vanrooij@donders.ru.nl">Iris
		<span class="icon-mail3"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.irisvanrooijcogsci.com">
		<span class="icon-html-five"></span>
		</a>
      </li>
    
      <li>
        <a href="//www.twitter.com/IrisVanRooij">
		<span class="icon-twitter"></span>
		</a>
      </li>
    
      <li>
        <a href="//github.com/IrisVanRooij">
		<span class="icon-github"></span>
		</a>
      </li>
      
  </ul>
<div class="credits">
<span>&copy; 2021 &nbsp;&nbsp;MARK BLOKPOEL AND IRIS VAN ROOIJ</span></br> <br>
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme</a> in <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>
  
<script>
  window.scalaFiddleTemplates = {

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }
,

    'mathlib': {
      pre: 'import scala.annotation.tailrec\nimport scala.util.Random\n\n/**\n * Implementation of basic set theory as implicits\n */\nobject SetTheory {\n  trait NumberSetOps[T] {\n    def sumElements(set: Set[T]): T\n    def mulElements(set: Set[T]): T\n  }\n\n  implicit object IntNumberOps extends NumberSetOps[Int] {\n    override def sumElements(set: Set[Int]): Int = set.sum\n    override def mulElements(set: Set[Int]): Int = set.product\n  }\n\n  implicit object DoubleNumberOps extends NumberSetOps[Double] {\n    override def sumElements(set: Set[Double]): Double = set.sum\n    override def mulElements(set: Set[Double]): Double = set.product\n  }\n\n  implicit object FloatNumberOps extends NumberSetOps[Float] {\n    override def sumElements(set: Set[Float]): Float = set.sum\n    override def mulElements(set: Set[Float]): Float = set.product\n  }\n\n  def powerset[A](set: Set[A]): Set[Set[A]] = set.subsets.toSet\n  def P[A](set: Set[A]): Set[Set[A]] = powerset(set)\n  def powerset[A](set: Set[A], len: Int): Set[Set[A]] = set.subsets(len).toSet\n  def P[A](set: Set[A], len: Int): Set[Set[A]] = powerset(set, len)\n  def powersetUp[A](set: Set[A], upperbound: Int): Set[Set[A]] =\n    (for(len <- 0 to upperbound) yield powerset(set, len)).toSet.flatten\n  def powersetLow[A](set: Set[A], lowerbound: Int): Set[Set[A]] =\n    (for(len <- lowerbound to set.size) yield powerset(set, len)).toSet.flatten\n\n\n  def argMax[A, T](set: Set[A], f: A => T)(implicit ord: Ordering[T]): Set[A] = {\n    val max = set.map(f).max  // find max value\n    set.filter(f(_) == max)           // return all elems with max value\n  }\n\n  def sum[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.sumElements(set)\n  def sum[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(f))\n  def sum[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.sumElements(set.map(pair => f(pair._1, pair._2)))\n\n  def product[T](set: Set[T])(implicit nso: NumberSetOps[T]): T = nso.mulElements(set)\n  def product[A, T](set: Set[A], f: A => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(f))\n  def product[A, T](set: Set[(A, A)], f: (A, A) => T)(implicit nso: NumberSetOps[T]): T = nso.mulElements(set.map(pair => f(pair._1, pair._2)))\n\n  def random[A](set: Set[A]): Option[A] = if (set.isEmpty) None\n  else Some(set.toList(Random.nextInt(set.size)))\n\n  implicit class ImplAny[A](elem: A) {\n    def in(set: Set[A]): Boolean = set.contains(elem)\n  }\n\n  implicit class ImplSet[A](set: Set[A]) {\n    // for set membership, use set.contains(element)\n\n    def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n    def <(set2: Set[A]): Boolean = isSubsetOf(set2)\n\n    def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n    def <=(set2: Set[A]): Boolean = isSubsetEqTo(set2)\n\n    def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n    def >(set2: Set[A]): Boolean = isSupersetOf(set2)\n\n    def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n    def >=(set2: Set[A]): Boolean = isSupersetEqTo(set2)\n\n    // for intersection use set.intersect(set2)\n    def /\\(set2: Set[A]): Set[A] = set.intersect(set2)\n\n    // for union use set.union(set2)\n    def \\/(set2: Set[A]): Set[A] = set.union(set2)\n\n    def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n    def |(f: A => Boolean): Set[A] = set build f\n\n    def \\(set2: Set[A]): Set[A] = set.diff(set2)\n\n    def cardinalProduct[B](set2: Set[B]): Set[(A, B)] =\n      for (x <- set; y <- set2) yield (x, y)\n    def x[B](set2: Set[B]): Set[(A, B)] = cardinalProduct(set2)\n\n    def pairs: Set[(A, A)] = for (x <- set; y <- set) yield (x, y)\n\n    def uniquePairs: Set[(A, A)] = for (x <- set; y <- set if x != y) yield (x, y)\n\n\tdef unorderedPairs: Set[Set[A]] = for (x <- set; y <- set) yield Set(x, y)\n\t\n\tdef unorderedUniquePairs: Set[Set[A]] = for (x <- set; y <- set if x != y) yield Set(x, y)\n\n    def powerset: Set[Set[A]] = SetTheory.powerset(set)\n    def P: Set[Set[A]] = SetTheory.powerset(set)\n\n    def allPartitions: Set[Set[Set[A]]] = {\n      if (set.isEmpty) Set.empty\n      else {\n        val hd = set.head\n        val solutions = set.tail.allPartitions\n        val part1 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.map(partitioning => {\n          partitioning + Set(hd)\n        })\n        val part2 = if (solutions.isEmpty) Set(Set(Set(hd)))\n        else solutions.flatMap(partitioning => partitioning.map(part => {\n          val a = part + hd\n          val b = partitioning - part\n          b + a\n        }))\n        part1.union(part2)\n      }\n    }\n\n    def argMax[T](f: A => T)(implicit ord: Ordering[T]): Set[A] = SetTheory.argMax(set, f)\n\n    def allBijections[B](target: Set[B]): Set[Map[A, B]] = {\n      val perm = target.toList.permutations.toSet\n      val bijections = perm\n        .map(set zip _)\n        .map(_.toMap)\n      bijections\n    }\n\n    def allMappings[B](coDomain: Set[B]): Set[Map[A, B]] = {\n      @tailrec\n      def allMappingsRec(domain: Set[A], coDomain: Set[B], acc: Set[Map[A,B]] = Set(Map[A,B]())): Set[Map[A, B]] = {\n        if(domain.isEmpty) acc\n        else if(coDomain.isEmpty) acc\n        else {\n          val newMappings: Set[(A, B)] = coDomain.map(domain.head -> _)\n          val newAcc = acc.flatMap(oldMapping => newMappings.map(oldMapping + _))\n          allMappingsRec(domain.tail, coDomain, newAcc)\n        }\n      }\n\n      allMappingsRec(set, coDomain)\n    }\n    \n    def random: Option[A] = SetTheory.random(set)\n  }\n  implicit class Impl2Set[A, B](sets: (Set[A], Set[B])) {\n    // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n    def build(f: (A, B) => Boolean): Set[(A, B)] =\n      (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    def |(f: (A, B) => Boolean): Set[(A, B)] = sets build f\n  }\n\n  implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n    def union: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n    def intersection: Set[A] =\n      if (setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n  }\n\n  def requirement(b: Boolean, msg: String): Unit =\n    if (!b) {\n      println(s"Requirement not met: $msg")\n      assert(false)\n    }\n}\n\nimport SetTheory._\nimport scalatags.JsDom.all._\n\ncase object Viz {\n\n  var vizCounter = 0\n\n  def render(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t  var script = document.createElement(\'script\');\n\t    script.onload = function () {\n  \t\t  requirejs.config({\n  \t\t    baseUrl: \'https://unpkg.com/\',\n  \t\t    paths: {\n            "d3-array": "d3-array@latest/dist/d3-array.min",\n            "d3-axis": "d3-axis@latest/dist/d3-axis.min",\n            "d3-brush": "d3-brush@latest/dist/d3-brush.min",\n            "d3-chord": "d3-chord@latest/dist/d3-chord.min",\n            "d3-color": "d3-color@latest/dist/d3-color.min",\n            "d3-contour": "d3-contour@latest/dist/d3-contour.min",\n            "d3-delaunay": "d3-delaunay@latest/dist/d3-delaunay.min",\n            "d3-dispatch": "d3-dispatch@latest/dist/d3-dispatch.min",\n            "d3-drag": "d3-drag@latest/dist/d3-drag.min",\n            "d3-dsv": "d3-dsv@latest/dist/d3-dsv.min",\n            "d3-ease": "d3-ease@latest/dist/d3-ease.min",\n            "d3-fetch": "d3-fetch@latest/dist/d3-fetch.min",\n            "d3-force": "d3-force@latest/dist/d3-force.min",\n            "d3-format": "d3-format@latest/dist/d3-format.min",\n            "d3-geo": "d3-geo@latest/dist/d3-geo.min",\n            "d3-hierarchy": "d3-hierarchy@latest/dist/d3-hierarchy.min",\n            "d3-interpolate": "d3-interpolate@latest/dist/d3-interpolate.min",\n            "d3-path": "d3-path@latest/dist/d3-path.min",\n            "d3-polygon": "d3-polygon@latest/dist/d3-polygon.min",\n            "d3-quadtree": "d3-quadtree@latest/dist/d3-quadtree.min",\n            "d3-random": "d3-random@latest/dist/d3-random.min",\n            "d3-scale": "d3-scale@latest/dist/d3-scale.min",\n            "d3-scale-chromatic": "d3-scale-chromatic@latest/dist/d3-scale-chromatic.min",\n            "d3-selection": "d3-selection@latest/dist/d3-selection.min",\n            "d3-shape": "d3-shape@latest/dist/d3-shape.min",\n            "d3-time": "d3-time@latest/dist/d3-time.min",\n            "d3-time-format": "d3-time-format@latest/dist/d3-time-format.min",\n            "d3-timer": "d3-timer@latest/dist/d3-timer.min",\n            "d3-transition": "d3-transition@latest/dist/d3-transition.min",\n            "d3-zoom": "d3-zoom@latest/dist/d3-zoom.min",\n            "d3": "d3@latest/dist/d3.min",\n            "@hpcc-js/wasm": "@hpcc-js/wasm@1.9.1/dist/index.min",\n    \t\t\t  "graphviz": "d3-graphviz@latest/build/d3-graphviz"\n  \t\t    }\n  \t\t  });\n\n  \t    require(["d3", "graphviz"], function(d3, viz) {\n    \t\t  const dotString = \'${dot}\';\n          viz.graphviz(\'#plot$vizCounter\')\n            .renderDot(dotString);\n        });\n\n  \t  };\n\n  \t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n  \t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n\n  def renderAlt(dot: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$vizCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://github.com/\',\n\t\t    paths: {\n\t\t\t  "viz": "lovelace/raw/master/assets/js/viz"\n\t\t    }\n\t\t  });\n\n\t    require(["viz"], function(viz) {\n  \t\t  const dotString = \'${dot}\';\n  \t\t  var svg = Viz(dotString, "svg");\n  \t\t  document.getElementById(\'plot$vizCounter\').innerHTML = svg;\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    vizCounter = vizCounter + 1\n  }\n}\n\nimport scala.util.Random\n\ncase class Person(name: String) {\n  override def toString: String = name\n  def likes(other: Person): Likes = Likes(this, other, true)\n  def dislikes(other: Person): Likes = Likes(this, other, false)\n}\n\ncase class Likes(a: Person, b: Person, likes: Boolean) {\n  def isAbout(pair: Set[Person]): Boolean = {\n\trequire(pair.size == 2, "pair in Likes.isAbout does not contain exactly 2 persons")\n\ta == pair.head && b == pair.tail.head ||\n\ta == pair.tail.head && b == pair.head\n  }\n  override def toString: String = if(likes) s"$a likes $b" else s"$a dislikes $b"\n}\n\n\ncase object Person {\n    private val names: Set[String] = Set("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n\n    def random: Person = Person(names.random.getOrElse("Easter Bunny"))\n\n    // Returns a set of k random persons.\n    def randomGroup(size: Int): Set[Person] = {\n        def rg(size: Int, namesLeft: Set[String]): Set[Person] = {\n            if(size == 0) Set.empty\n            else {\n                val newPerson = namesLeft.random\n                if(newPerson.isEmpty) Set.empty\n                else rg(size - 1, namesLeft - newPerson.get) + Person(newPerson.get)\n            }\n        }\n\n        rg(size, names)\n    }\n\n\timplicit class ImplPersons(persons: Set[Person]) {\n\t\tdef deriveLikeFunction(partialLikes: Set[Likes]): (Person, Person) => Boolean = {\n\t\t\t//require(persons.uniquePairs.forall(pair => partialLikes.find(like => like.a == pair._1 && like.b == pair._2) == partialLikes.find(like => like.a == pair._2 && like.b == pair._1)), s"partialLikes contains asymmetric like relations")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(pair => {\n\t\t\t\t\tval likeOption: Option[Likes] = partialLikes.find(_.isAbout(pair))\n\n\t\t\t\t\tif(likeOption.isDefined)\n\t\t\t\t\t\tpair -> likeOption.get.likes\n\t\t\t\t\telse\n\t\t\t\t\t\tpair -> false\n\t\t\t\t}).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef randomLikeFunction(probability: Double = 0.5): (Person, Person) => Boolean = {\n\t\t\trequire(probability >=0 && probability <= 1, "Probability must range from 0 and 1.")\n\n\t\t\tval completeLike: Map[Set[Person], Boolean] = persons.unorderedUniquePairs\n\t\t\t\t.map(_ -> (Random.nextDouble <= probability)).toMap\n\n\t\t\tdef like(a: Person, b: Person): Boolean = {\n\t\t\t\tif(completeLike.contains(Set(a,b))) completeLike(Set(a,b))\n\t\t\t\telse false\n\t\t\t}\n\n\t\t\tlike\n\t\t}\n\n\t\tdef toDotString(like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape = circle];\\\\n" +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head)) s"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else s"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\n\t\tdef toDotString(personsLiked: Set[Person], personsDisliked: Set[Person], like: (Person, Person) => Boolean): String = {\n\t\t\t"graph people {\\\\n" +\n\t\t\t"size=\\"7,7\\";\\\\n" +\n\t\t\t"ratio=compress;\\\\n" +\n\t\t\t"node [shape=circle,style=filled,fillcolor=darkolivegreen1];\\\\n" +\n\t\t\tpersonsLiked.mkString("",",",";\\\\n") +\n\t\t\t"node [shape=circle,style=filled,fillcolor=lightcoral];\\\\n" +\n\t\t\tpersonsDisliked.mkString("",",",";\\\\n") +\n\t\t\tpersons.unorderedUniquePairs.map(pair => {\n\t\t\t  if(like(pair.head, pair.tail.head))\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=dashed];"\n\t\t\t  else\n\t\t\t\ts"${pair.head} -- ${pair.tail.head} [style=solid];"\n\t\t\t}).mkString("\\\\n")+\n\t\t\t"}"\n\t\t}\n\t}\n}\n\ncase object SelectingInvitees {\n  case class Input(group: Set[Person],\n                   personsLiked: Set[Person],\n                   personsDisliked: Set[Person],\n                   like: (Person, Person) => Boolean,\n                   k: Int)\n\n   def inputGenerator(groupSize: Int,\n                      likeDislikeRatio: Double,\n                      pairLikeRatio: Double,\n                      k: Int,\n                      sampleSize: Int): List[Input] = {\n     (for(n <- 0 until sampleSize) yield {\n       val group = Person.randomGroup(groupSize)\n       val personsLiked = group.take((groupSize * likeDislikeRatio).intValue)\n       val personsDisliked = group.drop((groupSize * likeDislikeRatio).intValue)\n       def like = group.randomLikeFunction(pairLikeRatio)\n\n       Input(group, personsLiked, personsDisliked, like, k)\n     }).toList\n   }\n\n\tdef si4(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked must equal persons")\n\n    // Specify that invitees is valid if |G /\\ D| <= k.\n    def atMostKDislikes(invitees: Set[Person]): Boolean =\n        (invitees /\\ personsDisliked).size <= k\n\n    // Specify the optimality condition.\n    def xg(invitees: Set[Person]): Int = {\n        val x = invitees.uniquePairs // From all pairs of invitees,\n                .build(like.tupled)  // select all pairs that like each other,\n                .size                // and count them.\n        val g = invitees.size        // Count the number of total invitees.\n        x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .build(atMostKDislikes)       // select subsets that contain at most k disliked persons,\n        .argMax(xg)                   // and select the subsets that maximize the optimality condition.\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si5(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n    // Specify the optimality condition.\n    def gl_x_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val x  = invitees.uniquePairs // From all pairs of invitees,\n                 .build(like.tupled)  // select all pairs that like each other,\n                 .size                // and count them.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + x + g\n    }\n\n    val invitees = powerset(persons)  // From all possible subsets of persons,\n        .argMax(gl_x_g)               // select those that maximize |G/\\L| + |X| + |G|\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n\n\tdef si6(persons: Set[Person],\n        personsLiked: Set[Person],\n        personsDisliked: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n\n    // Input must satisfy these constraints, or program halts.\n    require(personsLiked <= persons, "personsLiked must be a subset of persons")\n    require(personsDisliked <= persons, "personsDisliked must be a subset of persons")\n    require(personsLiked /\\ personsDisliked == Set.empty, "intersection between personsLiked and personsDisliked must be emtpy")\n    require(personsLiked \\/ personsDisliked == persons, "union of personsLiked and personsLiked")\n\n\t// Specify that invitees is valid if |Y| <= k.\n    def atMostKPairDislikes(invitees: Set[Person]): Boolean =\n      { invitees.uniquePairs | like.tupled }.size <= k\n\n    // Specify the optimality condition.\n    def gl_g(invitees: Set[Person]): Int = {\n        val gl = (invitees /\\ personsLiked)\n    \t         .size                // Count the invitees the host likes.\n        val g  = invitees.size        // Count the number of total invitees.\n        gl + g\n    }\n\n    val invitees = { powerset(persons) | atMostKPairDislikes _ }\n                   .argMax(gl_g)\n\n    // If more than one solution exists, return one at random. Always 1 solution must exist,\n    // because the empty set is a valid solution. Hence, we can assume random does not\n    // return None and \'get\' the value.\n    invitees.random.get\n}\n}\n\nimport Person._\n\nimport scalatags.JsDom.all._\n\ncase object Plotly {\n\n  var plotCounter = 0\n\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Scatter = Value\n  }\n\n  case class Trace(data: List[(Double, Double)], name: String, plotType: PlotType.PlotType = PlotType.Scatter) {\n    val markers = if(plotType == PlotType.Scatter) "\\"mode\\": \\"markers\\"," else ""\n\n    def mean: Trace = {\n      def calcMean(xs: Iterable[Double]) = xs.sum / xs.size\n\n      val meanData = data.toMap.groupBy(_._1)\n        .mapValues(xs => calcMean(xs.map(_._2)))\n        .toList\n\n      Trace(meanData, name, plotType)\n    }\n\n    def toJSON: String = {\n      s"""\n      {\n        "name": "$name",\n        "type": "${plotType.toString.toLowerCase}",\n        $markers\n        "x": ${data.sortBy(_._1).map(_._1).mkString("[",",","]")},\n        "y": ${data.sortBy(_._1).map(_._2).mkString("[",",","]")}\n      }\n      """\n    }\n  }\n\n  case class Plot(traces: List[Trace], xAxisTitle: String = "", yAxisTitle: String = "") {\n    val xAxis = if(!xAxisTitle.isEmpty)\n      s"""\n      ,"xaxis": {\n        "title": {\n          "text": "$xAxisTitle"\n        }\n      }\n      """\n    else ""\n    val yAxis = if(!yAxisTitle.isEmpty)\n      s"""\n      ,"yaxis": {\n        "title": {\n          "text": "$yAxisTitle"\n        }\n      }\n      """\n    else ""\n\n    def toJSON: String = {\n      s"""\n      {\n        "data": ${traces.map(_.toJSON).mkString("[",",","]")},\n        "layout": {\n          "showlegend": "true",\n          "legend": {\n            "orientation": "v"\n          }\n          $xAxis\n          $yAxis\n        }\n      }\n      """\n    }\n\n    def render: Unit = Plotly.render(this.toJSON)\n  }\n\n  def render(plotJson: String): Unit = {\n    Fiddle.print(\n\t  div(id:=s"plot$plotCounter"),\n\t  script(s"""\n  \t    var script = document.createElement(\'script\');\n\t    script.onload = function () {\n\t\t  requirejs.config({\n\t\t    baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n\t\t    paths: {\n\t\t\t  "plotly": "plotly.js@2.3.1/dist/plotly.min.js?noext"\n\t\t    }\n\t\t  });\n\n\t    require(["plotly"], function(plotly) {\n\t\t  const figure = JSON.parse(\'${plotJson.filter(_ >= \' \')}\');\n\t\t  plotly.newPlot(\'plot$plotCounter\', figure.data, figure.layout).catch(console.warn);\n\t    });\n\t  };\n\n\t  script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n\t  document.head.appendChild(script);\n\t  """)\n    )\n    plotCounter = plotCounter + 1\n  }\n}\n\nimport Plotly._\n\nval result = {\n',
      post: '}\nif(!result.isInstanceOf[Unit]) println(result)'
    }

  }
</script>

<script defer src='https://embed.scalafiddle.io/integration.js'></script>
</body>
</html>
