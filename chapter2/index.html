<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Chapter 2 - Concepts and Notation &middot; Academic Jekyll
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/lovelace/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/lovelace/favicon.png" />
<link rel="shortcut icon" href="/lovelace/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</head>


  <body class="index">

    <div id="sidebar">
  <header>
    <h1 class="site-title">
      <a href="/lovelace/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Academic Jekyll
      </a>
    </h1>
    <p class="lead">Academic Jekyll based on Hydeout with custom extensions.</p>
  </header>
  <nav id="sidebar-nav-links">
  
  

  

  


  

  

  

  
    
      <a class="page-link "
          href="/lovelace/">Home</a>
    
  

  
    
      <a class="page-link "
          href="/lovelace/chapter1/">Chapter 1 - Scala</a>
    
  

  
    
      <a class="page-link  active"
          href="/lovelace/chapter2/">Chapter 2 - Concepts and Notation</a>
    
  

  
    
      <a class="page-link "
          href="/lovelace/chapter3/">Chapter 3 - Formalizing</a>
    
  

  
    
      <a class="page-link "
          href="/lovelace/about/">About</a>
    
  


  


  

  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/lovelace/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  

  

  <!-- Optional additional links to insert for icons links -->
</nav>

  &#169; Mark Blokpoel and Iris van Rooij. This material has been released under a <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU GPL v3</a> license.

</div>

    <main class="container">
      <div class="content">
  


  <div id="toc-wrapper">
<ul id="markdown-toc">
  <li><a href="#set-theory" id="markdown-toc-set-theory">Set theory</a></li>
</ul>

</div>

<p>Like sculpting, theoretical modeling requires its own set of dedicated tools. The theoretical modeler’s tools are mathematical concepts, formal expressions, and notational conventions. One can already get quite far with the basics in <em>set theory</em>, <em>functions</em> and <em>logic</em>. Below we present a brief primer. Readers who have taken introductory classes on these topics can skip this section without loss of continuity.</p>

<h1 id="set-theory">Set theory</h1>
<p>A set is a collection of distinct objects. For example, a set of people, animals or numbers. Sets are usually denoted by a capital letter and their elements listed between curly brackets. They can also be visualized as circles.</p>

<div data-scalafiddle="" data-template="Template" data-minheight="150">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"Ramiro"</span><span class="o">,</span> <span class="s">"Brenda"</span><span class="o">,</span> <span class="s">"Molly"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">animals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"turtle"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">,</span> <span class="s">"cuttlefish"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">numbers</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">12</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>When we want to write that an object <script type="math/tex">x</script> is (or is not) part of a set <script type="math/tex">X</script>, we use <em>set membership</em> notation:</p>

<div data-scalafiddle="" data-template="Template" data-minheight="150">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">persons</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"Ramiro"</span><span class="o">,</span> <span class="s">"Brenda"</span><span class="o">,</span> <span class="s">"Molly"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">persons</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="s">"Ramiro"</span><span class="o">))</span>
</code></pre></div></div>
</div>

<div data-scalafiddle="" data-template="Template" data-minheight="150">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">numbers</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">12</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">numbers</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="mi">17</span><span class="o">))</span>
</code></pre></div></div>
</div>

<p>Often, we want to express things like ‘the set of mammals <script type="math/tex">M</script> is part of the set of all animals <script type="math/tex">A</script>’. We then use <em>subset</em> notation: <script type="math/tex">M\subseteq A</script> or <script type="math/tex">M\subset A</script>. The latter means that <script type="math/tex">M</script> is smaller than <script type="math/tex">A</script>.</p>

<div data-scalafiddle="" data-template="Template" data-minheight="150">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">animals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"turtle"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">,</span> <span class="s">"cuttlefish"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">mammals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="n">mammals</span> <span class="n">isSubsetOf</span> <span class="n">animals</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">mammals</span> <span class="n">isSubsetEqTo</span> <span class="n">animals</span><span class="o">)</span>
</code></pre></div></div>
</div>

<p>Vice versa, we can express that ‘the set of all things on earth <script type="math/tex">T</script> contains all animals <script type="math/tex">A</script>’ using <em>superset</em> notation: <script type="math/tex">T\supseteq A</script> or <script type="math/tex">T\supset A</script>. The latter means that <script type="math/tex">T</script> is bigger than <script type="math/tex">A</script>.</p>

<div data-scalafiddle="" data-template="Template" data-minheight="150">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">manyAnimals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"dog"</span><span class="o">,</span> <span class="s">"goldfish"</span><span class="o">,</span> <span class="s">"turtle"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">,</span>
  <span class="s">"cuttlefish"</span><span class="o">,</span> <span class="s">"shark"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">animals</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="s">"turtle"</span><span class="o">,</span> <span class="s">"blue whale"</span><span class="o">,</span> <span class="s">"cuttlefish"</span><span class="o">)</span>


<span class="nf">println</span><span class="o">(</span><span class="n">manyAnimals</span> <span class="n">isSupersetOf</span> <span class="n">animals</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">manyAnimals</span> <span class="n">isSupersetEqTo</span> <span class="n">animals</span><span class="o">)</span>
</code></pre></div></div>
</div>



  

  

</div>
    </main>

    <!-- Optional footer content -->

  
<script>
  window.scalaFiddleTemplates = {

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: A = set.toList(Random.nextInt(set.size))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: A = set.toList(Random.nextInt(set.size))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: A = set.toList(Random.nextInt(set.size))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: A = set.toList(Random.nextInt(set.size))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: A = set.toList(Random.nextInt(set.size))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }

  }
</script>

<script defer src='https://embed.scalafiddle.io/integration.js'></script>
</body>
</html>
