<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Chapter 3 - Formalizing &middot; Academic Jekyll
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/lovelace/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/lovelace/favicon.png" />
<link rel="shortcut icon" href="/lovelace/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</head>


  <body class="index">

    <div id="sidebar">
  <header>
    <h1 class="site-title">
      <a href="/lovelace/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Academic Jekyll
      </a>
    </h1>
    <p class="lead">Academic Jekyll based on Hydeout with custom extensions.</p>
  </header>
  <nav id="sidebar-nav-links">
  
  

  

  


  

  

  

  
    
      <a class="page-link "
          href="/lovelace/">Home</a>
    
  

  
    
      <a class="page-link "
          href="/lovelace/chapter1/">Chapter 1 - Scala</a>
    
  

  
    
      <a class="page-link "
          href="/lovelace/chapter2/">Chapter 2 - Concepts and Notation</a>
    
  

  
    
      <a class="page-link  active"
          href="/lovelace/chapter3/">Chapter 3 - Formalizing</a>
    
  

  
    
      <a class="page-link "
          href="/lovelace/about/">About</a>
    
  


  


  

  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/lovelace/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  

  

  <!-- Optional additional links to insert for icons links -->
</nav>

  &#169; Mark Blokpoel and Iris van Rooij. This material has been released under a <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU GPL v3</a> license.

</div>

    <main class="container">
      <div class="content">
  


  <div id="toc-wrapper">
<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
</ul>

</div>

<h1 id="introduction">Introduction</h1>

<div data-scalafiddle="" data-template="Persons" data-minheight="200" data-layout="v70">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">si4</span><span class="o">(</span>
  <span class="n">p</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">l</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">d</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span>
  <span class="n">k</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">requirement</span><span class="o">(</span><span class="n">l</span> <span class="n">subsetOf</span> <span class="n">p</span><span class="o">,</span> <span class="s">"l must be a subset of p"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">(</span><span class="n">d</span> <span class="n">subsetOf</span> <span class="n">p</span><span class="o">,</span> <span class="s">"d must be a subset of p"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">((</span><span class="n">l</span> <span class="n">intersect</span> <span class="n">d</span><span class="o">).</span><span class="py">isEmpty</span><span class="o">,</span> <span class="s">"intersection between l and d must be emtpy"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">((</span><span class="n">l</span> <span class="n">union</span> <span class="n">d</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">,</span> <span class="s">"union of l and d must equal p"</span><span class="o">)</span>


  <span class="nv">p</span><span class="o">.</span><span class="py">subsets</span><span class="o">.</span><span class="py">toSet</span> <span class="c1">// G \subseteq P</span>
   <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">g</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">intersect</span> <span class="n">d</span><span class="o">).</span><span class="py">size</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="c1">// such that |G \cap D| &lt;= k</span>
   <span class="o">.</span><span class="py">argMax</span><span class="o">(</span><span class="n">g</span> <span class="k">=&gt;</span> <span class="nv">g</span><span class="o">.</span><span class="py">size</span> <span class="o">+</span> <span class="nv">g</span><span class="o">.</span><span class="py">pairs</span><span class="o">.</span><span class="py">build</span><span class="o">(</span><span class="nv">Function</span><span class="o">.</span><span class="py">tupled</span><span class="o">(</span><span class="n">like</span><span class="o">)).</span><span class="py">size</span><span class="o">)</span>
   <span class="o">.</span><span class="py">get</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">si5</span><span class="o">(</span>
  <span class="n">p</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">l</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">d</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span>
  <span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">requirement</span><span class="o">(</span><span class="n">l</span> <span class="n">subsetOf</span> <span class="n">p</span><span class="o">,</span> <span class="s">"l must be a subset of p"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">(</span><span class="n">d</span> <span class="n">subsetOf</span> <span class="n">p</span><span class="o">,</span> <span class="s">"d must be a subset of p"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">((</span><span class="n">l</span> <span class="n">intersect</span> <span class="n">d</span><span class="o">).</span><span class="py">isEmpty</span><span class="o">,</span> <span class="s">"intersection between l and d must be emtpy"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">((</span><span class="n">l</span> <span class="n">union</span> <span class="n">d</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">,</span> <span class="s">"union of l and d must equal p"</span><span class="o">)</span>


  <span class="nv">p</span><span class="o">.</span><span class="py">subsets</span><span class="o">.</span><span class="py">toSet</span> <span class="c1">// G \subseteq P</span>
   <span class="o">.</span><span class="py">argMax</span><span class="o">(</span><span class="n">g</span> <span class="k">=&gt;</span> <span class="o">{</span>
     <span class="o">(</span><span class="n">g</span> <span class="n">intersect</span> <span class="n">l</span><span class="o">).</span><span class="py">size</span> <span class="c1">// |G \cap L|</span>
     <span class="o">+</span> <span class="nv">g</span><span class="o">.</span><span class="py">size</span> <span class="c1">// |G|</span>
     <span class="o">+</span> <span class="nv">g</span><span class="o">.</span><span class="py">pairs</span><span class="o">.</span><span class="py">build</span><span class="o">(</span><span class="n">pair</span> <span class="k">=&gt;</span> <span class="nf">like</span><span class="o">(</span><span class="nv">pair</span><span class="o">.</span><span class="py">_1</span><span class="o">,</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_2</span><span class="o">)).</span><span class="py">size</span> <span class="c1">// |X|</span>
   <span class="o">})</span>
   <span class="o">.</span><span class="py">get</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">si6</span><span class="o">(</span>
  <span class="n">p</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">l</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">d</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
  <span class="n">like</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span>
  <span class="n">k</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">requirement</span><span class="o">(</span><span class="n">l</span> <span class="n">subsetOf</span> <span class="n">p</span><span class="o">,</span> <span class="s">"l must be a subset of p"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">(</span><span class="n">d</span> <span class="n">subsetOf</span> <span class="n">p</span><span class="o">,</span> <span class="s">"d must be a subset of p"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">((</span><span class="n">l</span> <span class="n">intersect</span> <span class="n">d</span><span class="o">).</span><span class="py">isEmpty</span><span class="o">,</span> <span class="s">"intersection between l and d must be emtpy"</span><span class="o">)</span>
  <span class="nf">requirement</span><span class="o">((</span><span class="n">l</span> <span class="n">union</span> <span class="n">d</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">,</span> <span class="s">"union of l and d must equal p"</span><span class="o">)</span>


  <span class="nv">p</span><span class="o">.</span><span class="py">subsets</span><span class="o">.</span><span class="py">toSet</span> <span class="c1">// G \subseteq P</span>
   <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">g</span> <span class="k">=&gt;</span> <span class="nv">g</span><span class="o">.</span><span class="py">pairs</span><span class="o">.</span><span class="py">build</span><span class="o">(</span><span class="n">pair</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="nf">like</span><span class="o">(</span><span class="nv">pair</span><span class="o">.</span><span class="py">_1</span><span class="o">,</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_2</span><span class="o">)).</span><span class="py">size</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span>
   <span class="o">.</span><span class="py">argMax</span><span class="o">(</span><span class="n">g</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">intersect</span> <span class="n">l</span><span class="o">).</span><span class="py">size</span> <span class="o">+</span> <span class="nv">g</span><span class="o">.</span><span class="py">size</span><span class="o">)</span>
   <span class="o">.</span><span class="py">get</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Ada"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Cal"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Deb"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">e</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Edo"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">f</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Fae"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">relations</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span>
  <span class="n">a</span> <span class="n">likes</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="n">likes</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span> <span class="n">likes</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span> <span class="n">likes</span> <span class="n">f</span><span class="o">,</span> <span class="n">d</span> <span class="n">likes</span> <span class="n">e</span><span class="o">,</span> <span class="n">d</span> <span class="n">likes</span> <span class="n">f</span><span class="o">,</span> <span class="n">e</span> <span class="n">likes</span> <span class="n">f</span>
<span class="o">)</span>

<span class="k">val</span> <span class="nv">P</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">](</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">L</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">](</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">D</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">](</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">outputSI4</span> <span class="k">=</span> <span class="nf">si4</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="nv">relations</span><span class="o">.</span><span class="py">deriveFun</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">outputSI5</span> <span class="k">=</span> <span class="nf">si5</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="nv">relations</span><span class="o">.</span><span class="py">deriveFun</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">outputSI6</span> <span class="k">=</span> <span class="nf">si6</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="nv">relations</span><span class="o">.</span><span class="py">deriveFun</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="nv">VegaRenderer</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">relations</span><span class="o">.</span><span class="py">deriveGraph</span><span class="o">(</span><span class="n">P</span><span class="o">))</span>

<span class="nf">println</span><span class="o">(</span><span class="s">"SI4: "</span> <span class="o">+</span> <span class="n">outputSI4</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"SI5: "</span> <span class="o">+</span> <span class="n">outputSI5</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"SI6: "</span> <span class="o">+</span> <span class="n">outputSI6</span><span class="o">)</span>
</code></pre></div></div>
</div>



  

  

</div>
    </main>

    <!-- Optional footer content -->

  
<script>
  window.scalaFiddleTemplates = {

    'Persons': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: A = set.toList(Random.nextInt(set.size))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n\ncase class Person(name: String) {\n  def likes(other: Person): Relation = Relation(this, other, true)\n  def dislikes(other: Person): Relation = Relation(this, other, false)\n\n  override def toString: String = name\n}\n\ncase object Person {\n    val names = List("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n    def random: Person = Person(names(Random.nextInt(names.length)))\n    def randomSet(size: Int): Set[Person] = List.tabulate(size)(_ => Person.random).toSet\n}\n\ncase class Relation(a: Person, b: Person, liking: Boolean) {\n    def canEqual(a: Any) = a.isInstanceOf[Relation]\n\n    override def equals(that: Any): Boolean = that match {\n        case that: Relation => {\n            this.liking == that.liking && (this.a == that.a && this.b == that.b || this.a == that.b && this.b == that.a)\n        }\n        case _ => false\n    }\n}\n\nobject Helpers {\n  import Math._\n\n  implicit class ImplRelation(personA: String) {\n    def likes(personB: String): Relation = Relation(Person(personA), Person(personB), true)\n\n    def dislikes(personB: String): Relation = Relation(Person(personA), Person(personB), false)\n  }\n\n  implicit class ImplRelFun(relations: Set[Relation]) {\n    def deriveFun: ((Person, Person) => Boolean) = {\n      (a: Person, b: Person) => {\n        val rel = relations.find(p => p.a == a && p.b == b || p.a == b && p.b == a)\n        if(rel.isDefined) rel.get.liking\n        else false\n      }\n    }\n\n    def deriveGraph(persons: Set[Person]): Graph = {\n      val edges = for(p1 <- persons; p2 <- persons if p1 != p2) yield {\n        val col = if(deriveFun(p1, p2)) "likes" else "dislikes"\n        (p1, p2, col)\n      }\n      Graph(persons.toList, edges.toList)\n    }\n  }\n}\n\nimport Math._\nimport Helpers._\n\n',
      post: ''
    }

  }
</script>

<script defer src='https://embed.scalafiddle.io/integration.js'></script>
</body>
</html>
