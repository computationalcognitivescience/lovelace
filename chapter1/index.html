<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Chapter 1 - Scala &middot; Academic Jekyll
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</head>


  <body class="index">

    <div id="sidebar">
  <header>
    <h1 class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Academic Jekyll
      </a>
    </h1>
    <p class="lead">Academic Jekyll based on Hydeout with custom extensions.</p>
  </header>
  <nav id="sidebar-nav-links">
  
  

  

  


  

  

  

  
    
      <a class="page-link "
          href="/">Home</a>
    
  

  
    
      <a class="page-link  active"
          href="/chapter1/">Chapter 1 - Scala</a>
    
  

  
    
      <a class="page-link "
          href="/chapter2/">Chapter 2 - Citations</a>
    
  

  
    
      <a class="page-link "
          href="/chapter3/">Chapter 3 - LaTeX</a>
    
  

  
    
      <a class="page-link "
          href="/about/">About</a>
    
  


  


  

  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  

  

  <!-- Optional additional links to insert for icons links -->
</nav>

  &#169; Mark Blokpoel. This material has been released under a <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU GPL v3</a> license.

</div>

    <main class="container">
      <div class="content">
  


  <div id="toc-wrapper">
<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#simple-bar-plot" id="markdown-toc-simple-bar-plot">Simple bar plot</a></li>
  <li><a href="#simple-line-plot" id="markdown-toc-simple-line-plot">Simple line plot</a></li>
  <li><a href="#simple-dot-plot" id="markdown-toc-simple-dot-plot">Simple dot plot</a></li>
  <li><a href="#plotting-simple-graphs" id="markdown-toc-plotting-simple-graphs">Plotting simple graphs</a></li>
  <li><a href="#plotting-via-custom-vega-lite-spec" id="markdown-toc-plotting-via-custom-vega-lite-spec">Plotting via custom vega-lite spec</a></li>
</ul>

</div>

<h1 id="introduction">Introduction</h1>
<p>You can embed scala using scalafiddle:</p>

<div data-scalafiddle="" data-template="Template" data-layout="v50">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">println</span><span class="o">(</span><span class="s">"Hello world!"</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h1 id="simple-bar-plot">Simple bar plot</h1>
<p>We can do more advanced plotting using the scala functionality:</p>

<div data-scalafiddle="" data-template="Template" data-minheight="800" data-layout="v50">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">data1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"A"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">28</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">55</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">43</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mf">91.4</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">81</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"F"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">53</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"G"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">19</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"H"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">87</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">52</span><span class="o">)</span>
  <span class="o">)</span>

<span class="k">val</span> <span class="nv">data2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"A"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">51</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">75</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">14</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">11</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">43</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"F"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">33</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"G"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">9</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"H"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">78</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">72</span><span class="o">)</span>
<span class="o">)</span>

<span class="nf">render</span><span class="o">(</span><span class="n">traces</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Trace</span><span class="o">(</span><span class="s">"data1"</span><span class="o">,</span> <span class="n">data1</span><span class="o">),</span> <span class="nc">Trace</span><span class="o">(</span><span class="s">"data2"</span><span class="o">,</span> <span class="n">data2</span><span class="o">)),</span>
       <span class="n">xValue</span> <span class="k">=</span> <span class="s">"a"</span><span class="o">,</span>
       <span class="n">xLabel</span> <span class="k">=</span> <span class="s">"xAxis"</span><span class="o">,</span>
       <span class="n">yValue</span> <span class="k">=</span> <span class="s">"b"</span><span class="o">,</span>
       <span class="n">yLabel</span> <span class="k">=</span> <span class="s">"yAxis"</span><span class="o">,</span>
       <span class="n">title</span> <span class="k">=</span> <span class="s">"myTitle"</span><span class="o">,</span>
       <span class="n">plotType</span> <span class="k">=</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Bar</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h1 id="simple-line-plot">Simple line plot</h1>
<p>We can do more advanced plotting using the scala functionality:</p>

<div data-scalafiddle="" data-template="Template" data-minheight="800" data-layout="v50">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">data1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"A"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">28</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">55</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">43</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mf">91.4</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">81</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"F"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">53</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"G"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">19</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"H"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">87</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">52</span><span class="o">)</span>
  <span class="o">)</span>

<span class="k">val</span> <span class="nv">data2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"A"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">51</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">75</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">14</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">11</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">43</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"F"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">33</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"G"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">9</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"H"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">78</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">72</span><span class="o">)</span>
<span class="o">)</span>

<span class="nf">render</span><span class="o">(</span><span class="n">traces</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Trace</span><span class="o">(</span><span class="s">"data1"</span><span class="o">,</span> <span class="n">data1</span><span class="o">),</span> <span class="nc">Trace</span><span class="o">(</span><span class="s">"data2"</span><span class="o">,</span> <span class="n">data2</span><span class="o">)),</span>
       <span class="n">xValue</span> <span class="k">=</span> <span class="s">"a"</span><span class="o">,</span>
       <span class="n">xLabel</span> <span class="k">=</span> <span class="s">"xAxis"</span><span class="o">,</span>
       <span class="n">yValue</span> <span class="k">=</span> <span class="s">"b"</span><span class="o">,</span>
       <span class="n">yLabel</span> <span class="k">=</span> <span class="s">"yAxis"</span><span class="o">,</span>
       <span class="n">title</span> <span class="k">=</span> <span class="s">"myTitle"</span><span class="o">,</span>
       <span class="n">plotType</span> <span class="k">=</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Line</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h1 id="simple-dot-plot">Simple dot plot</h1>
<p>We can do more advanced plotting using the scala functionality:</p>

<div data-scalafiddle="" data-template="Template" data-minheight="800" data-layout="v50">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">data1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"A"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">28</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">55</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">43</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mf">91.4</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">81</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"F"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">53</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"G"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">19</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"H"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">87</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">52</span><span class="o">)</span>
  <span class="o">)</span>

<span class="k">val</span> <span class="nv">data2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"A"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">51</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">75</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">14</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">11</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">43</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"F"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">33</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"G"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">9</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"H"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">78</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">72</span><span class="o">)</span>
<span class="o">)</span>

<span class="nf">render</span><span class="o">(</span><span class="n">traces</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Trace</span><span class="o">(</span><span class="s">"data1"</span><span class="o">,</span> <span class="n">data1</span><span class="o">),</span> <span class="nc">Trace</span><span class="o">(</span><span class="s">"data2"</span><span class="o">,</span> <span class="n">data2</span><span class="o">)),</span>
       <span class="n">xValue</span> <span class="k">=</span> <span class="s">"a"</span><span class="o">,</span>
       <span class="n">xLabel</span> <span class="k">=</span> <span class="s">"xAxis"</span><span class="o">,</span>
       <span class="n">yValue</span> <span class="k">=</span> <span class="s">"b"</span><span class="o">,</span>
       <span class="n">yLabel</span> <span class="k">=</span> <span class="s">"yAxis"</span><span class="o">,</span>
       <span class="n">title</span> <span class="k">=</span> <span class="s">"myTitle"</span><span class="o">,</span>
       <span class="n">plotType</span> <span class="k">=</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Point</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h1 id="plotting-simple-graphs">Plotting simple graphs</h1>
<div data-scalafiddle="" data-template="Template" data-minheight="600" data-layout="v35">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">nodes</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"F"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">edges</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="s">"A"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span> <span class="s">"y"</span><span class="o">),</span> <span class="c1">// node 1, node 2, edge label</span>
  <span class="o">(</span><span class="s">"A"</span><span class="o">,</span><span class="s">"C"</span><span class="o">,</span> <span class="s">"y"</span><span class="o">),</span>
  <span class="o">(</span><span class="s">"D"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span> <span class="s">"n"</span><span class="o">),</span>
  <span class="o">(</span><span class="s">"E"</span><span class="o">,</span><span class="s">"F"</span><span class="o">,</span> <span class="s">"m"</span><span class="o">)</span>
<span class="o">)</span>

<span class="nf">render</span><span class="o">(</span><span class="nc">Graph</span><span class="o">(</span><span class="n">nodes</span><span class="o">,</span> <span class="n">edges</span><span class="o">))</span>
</code></pre></div></div>
</div>

<h1 id="plotting-via-custom-vega-lite-spec">Plotting via custom vega-lite spec</h1>
<p>We can do plots via Vega-lite by passing any spec string:</p>

<div data-scalafiddle="" data-template="Template" data-minheight="800" data-layout="v65">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">VegaRenderer</span><span class="o">.</span><span class="py">render</span><span class="o">(</span>
<span class="s">"""
    $schema: 'https://vega.github.io/schema/vega-lite/v2.0.json',
    description: 'A simple bar chart with embedded data.',
    data: {
      values: [
        {a: 'A', b: 28},
        {a: 'B', b: 55},
        {a: 'C', b: 43},
        {a: 'D', b: 91},
        {a: 'E', b: 81},
        {a: 'F', b: 53},
        {a: 'G', b: 19},
        {a: 'H', b: 87},
        {a: 'I', b: 52}
      ]
    },
    mark: 'bar',
    encoding: {
      x: {field: 'a', type: 'ordinal'},
      y: {field: 'b', type: 'quantitative'}
    }
"""</span>
<span class="o">)</span>
</code></pre></div></div>
</div>



  

  

</div>
    </main>

    <!-- Optional footer content -->

  
<script>
  window.scalaFiddleTemplates = {

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argmax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argmax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argmax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argmax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argmax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }
,

    'Template': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@3?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@2?noext",\n              "vega": "vega@3?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "mark": "${plotType.toString.toLowerCase}",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal"},\n            "y": {"field": "$yValue", "type": "quantitative"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argmax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n',
      post: ''
    }

  }
</script>

<script defer src='https://embed.scalafiddle.io/integration.js'></script>
</body>
</html>
